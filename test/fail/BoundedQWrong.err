MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "BoundedQWrong.ma" ---
--- scope checking ---
--- type checking ---
type  Nat : + Size -> Set
term  zero : .[s!ze : Size] -> .[i < s!ze] -> Nat s!ze
term  zero : .[i : Size] -> < zero i : Nat $i >
term  succ : .[s!ze : Size] -> .[i < s!ze] -> ^ Nat i -> Nat s!ze
term  succ : .[i : Size] -> ^(y1 : Nat i) -> < succ i y1 : Nat $i >
type  Nat : + Size -> Set
block fails as expected, error message:
mySucc
/// checkExpr 0 |- \ i -> \ j -> \ n -> succ j n : .[i : Size] -> .[j : Size] -> |j| < |i| -> Nat i -> Nat j
/// checkForced fromList [] |- \ i -> \ j -> \ n -> succ j n : .[i : Size] -> .[j : Size] -> |j| < |i| -> Nat i -> Nat j
/// new i : Size
/// checkExpr 1 |- \ j -> \ n -> succ j n : .[j : Size] -> |j| < |i| -> Nat i -> Nat j
/// checkForced fromList [(i,0)] |- \ j -> \ n -> succ j n : .[j : Size] -> |j| < |i| -> Nat i -> Nat j
/// new j : Size
/// checkExpr 2 |- \ n -> succ j n : |j| < |i| -> Nat i -> Nat j
/// adding size rel. v1 + 1 <= v0
/// checkExpr 2 |- \ n -> succ j n : Nat i -> Nat j
/// checkForced fromList [(j,1),(i,0)] |- \ n -> succ j n : Nat i -> Nat j
/// new n : (Nat v0)
/// checkExpr 3 |- succ j n : Nat j
/// checkForced fromList [(j,1),(i,0),(n,2)] |- succ j n : Nat j
/// leqVal' (subtyping) [(j,1),(i,0),(n,2)] |- < n : Nat i >  <=+  Nat j
/// leqVal' (subtyping) [(j,1),(i,0),(n,2)] |- Nat i  <=+  Nat j
/// leqVal' [(j,1),(i,0),(n,2)] |- i  <=+  j : Size
/// leSize v0 <=+ v1
/// leSize' v0 <= v1
/// bound not entailed
error during typechecking:
explicitCast
/// checkExpr 0 |- \ i -> \ j -> \ n -> n : .[i : Size] -> .[j : Size] -> |j| <= |i| -> Nat i -> Nat j
/// checkForced fromList [] |- \ i -> \ j -> \ n -> n : .[i : Size] -> .[j : Size] -> |j| <= |i| -> Nat i -> Nat j
/// new i : Size
/// checkExpr 1 |- \ j -> \ n -> n : .[j : Size] -> |j| <= |i| -> Nat i -> Nat j
/// checkForced fromList [(i,0)] |- \ j -> \ n -> n : .[j : Size] -> |j| <= |i| -> Nat i -> Nat j
/// new j : Size
/// checkExpr 2 |- \ n -> n : |j| <= |i| -> Nat i -> Nat j
/// adding size rel. v1 + 0 <= v0
/// checkExpr 2 |- \ n -> n : Nat i -> Nat j
/// checkForced fromList [(j,1),(i,0)] |- \ n -> n : Nat i -> Nat j
/// new n : (Nat v0)
/// checkExpr 3 |- n : Nat j
/// leqVal' (subtyping) [(j,1),(i,0),(n,2)] |- < n : Nat i >  <=+  Nat j
/// leqVal' (subtyping) [(j,1),(i,0),(n,2)] |- Nat i  <=+  Nat j
/// leqVal' [(j,1),(i,0),(n,2)] |- i  <=+  j : Size
/// leSize v0 <=+ v1
/// leSize' v0 <= v1
/// bound not entailed
