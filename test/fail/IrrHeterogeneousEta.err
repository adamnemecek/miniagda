MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "IrrHeterogeneousEta.ma" ---
--- scope checking ---
--- type checking ---
type  Unit : Set
term  unit : < unit : Unit >
type  Bool : Set
term  true : < true : Bool >
term  false : < false : Bool >
type  T : Bool -> Set
{ T true = Bool -> Bool
; T false = Bool
}
block fails as expected, error message:
etaFun'
/// checkExpr 0 |- \ F -> \ g -> \ h -> g (h true) : .[F : .[b : Bool] -> (T b -> T b) -> Bool -> Set] -> (g : F [false] (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// checkForced fromList [] |- \ F -> \ g -> \ h -> g (h true) : .[F : .[b : Bool] -> (T b -> T b) -> Bool -> Set] -> (g : F [false] (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// new F : (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set)
/// checkExpr 1 |- \ g -> \ h -> g (h true) : (g : F false (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// checkForced fromList [(F,0)] |- \ g -> \ h -> g (h true) : (g : F false (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// new g : ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}} {true {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))})
/// checkExpr 2 |- \ h -> g (h true) : (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// checkForced fromList [(g,1),(F,0)] |- \ h -> g (h true) : (h : (a : Bool) -> F [true] (\ x -> \ y -> x y) a) -> Bool
/// new h : ((a : Bool::Tm) -> F [true] (\ x -> \ y -> x y) a{g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}} {true {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Bool -> Set))})
/// checkExpr 3 |- g (h true) : Bool
/// inferExpr' g (h true)
/// leqVal' (subtyping)  < h true : F true (\ x -> \ y -> x y) true >  <=+  F false (\ x -> x) true
/// leqVal' (subtyping)  F true (\ x -> \ y -> x y) true  <=+  F false (\ x -> x) true
/// leqVal'  \ x -> \ y -> x y : (Bool -> Bool) -> T true  <=*  \ x -> x : Bool -> T false
/// new x : (Bool::Tm -> Bool)||Bool
/// leqVal'  \ y -> x y : Bool -> Bool  <=*  x : Bool
/// type (Bool::Tm -> Bool) has different shape than Bool
block fails as expected, error message:
etaFun
/// checkExpr 0 |- \ F -> \ g -> \ a -> g a : .[F : .[b : Bool] -> (T b -> T b) -> Set] -> (g : F [false] (\ x -> x) -> Bool) -> (a : F [true] (\ x -> \ y -> x y)) -> Bool
/// checkForced fromList [] |- \ F -> \ g -> \ a -> g a : .[F : .[b : Bool] -> (T b -> T b) -> Set] -> (g : F [false] (\ x -> x) -> Bool) -> (a : F [true] (\ x -> \ y -> x y)) -> Bool
/// new F : (.[b : Bool::Tm] -> (T b -> T b) -> Set)
/// checkExpr 1 |- \ g -> \ a -> g a : (g : F false (\ x -> x) -> Bool) -> (a : F [true] (\ x -> \ y -> x y)) -> Bool
/// checkForced fromList [(F,0)] |- \ g -> \ a -> g a : (g : F false (\ x -> x) -> Bool) -> (a : F [true] (\ x -> \ y -> x y)) -> Bool
/// new g : ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))})
/// checkExpr 2 |- \ a -> g a : (a : F true (\ x -> \ y -> x y)) -> Bool
/// checkForced fromList [(g,1),(F,0)] |- \ a -> g a : (a : F true (\ x -> \ y -> x y)) -> Bool
/// new a : (v0 {true {g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}} {\ x -> \ y -> x y {g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (T b -> T b) -> Set))}})
/// checkExpr 3 |- g a : Bool
/// inferExpr' g a
/// leqVal' (subtyping)  < a : F true (\ x -> \ y -> x y) >  <=+  F false (\ x -> x)
/// leqVal' (subtyping)  F true (\ x -> \ y -> x y)  <=+  F false (\ x -> x)
/// leqVal'  \ x -> \ y -> x y : (Bool -> Bool) -> T true  <=*  \ x -> x : Bool -> T false
/// new x : (Bool::Tm -> Bool)||Bool
/// leqVal'  \ y -> x y : Bool -> Bool  <=*  x : Bool
/// type (Bool::Tm -> Bool) has different shape than Bool
type  U : Bool -> Set
{ U true = Unit
; U false = Bool
}
block fails as expected, error message:
etaUnit'
/// checkExpr 0 |- \ F -> \ g -> \ h -> g (h true) : .[F : .[b : Bool] -> (U b -> U b) -> Bool -> Set] -> (g : F [false] (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// checkForced fromList [] |- \ F -> \ g -> \ h -> g (h true) : .[F : .[b : Bool] -> (U b -> U b) -> Bool -> Set] -> (g : F [false] (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// new F : (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set)
/// checkExpr 1 |- \ g -> \ h -> g (h true) : (g : F false (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// checkForced fromList [(F,0)] |- \ g -> \ h -> g (h true) : (g : F false (\ x -> x) true -> Bool) -> (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// new g : ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}} {true {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))})
/// checkExpr 2 |- \ h -> g (h true) : (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// checkForced fromList [(g,1),(F,0)] |- \ h -> g (h true) : (h : (a : Bool) -> F [true] (\ x -> unit) a) -> Bool
/// new h : ((a : Bool::Tm) -> F [true] (\ x -> unit) a{g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}} {true {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Bool -> Set))})
/// checkExpr 3 |- g (h true) : Bool
/// inferExpr' g (h true)
/// leqVal' (subtyping)  < h true : F true (\ x -> unit) true >  <=+  F false (\ x -> x) true
/// leqVal' (subtyping)  F true (\ x -> unit) true  <=+  F false (\ x -> x) true
/// leqVal'  \ x -> unit : Unit -> U true  <=*  \ x -> x : Bool -> U false
/// new x : Unit||Bool
/// leqVal'  unit : Unit  <=*  x : Bool
/// type Unit has different shape than Bool
error during typechecking:
etaUnit
/// checkExpr 0 |- \ F -> \ g -> \ a -> g a : .[F : .[b : Bool] -> (U b -> U b) -> Set] -> (g : F [false] (\ x -> x) -> Bool) -> (a : F [true] (\ x -> unit)) -> Bool
/// checkForced fromList [] |- \ F -> \ g -> \ a -> g a : .[F : .[b : Bool] -> (U b -> U b) -> Set] -> (g : F [false] (\ x -> x) -> Bool) -> (a : F [true] (\ x -> unit)) -> Bool
/// new F : (.[b : Bool::Tm] -> (U b -> U b) -> Set)
/// checkExpr 1 |- \ g -> \ a -> g a : (g : F false (\ x -> x) -> Bool) -> (a : F [true] (\ x -> unit)) -> Bool
/// checkForced fromList [(F,0)] |- \ g -> \ a -> g a : (g : F false (\ x -> x) -> Bool) -> (a : F [true] (\ x -> unit)) -> Bool
/// new g : ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))})
/// checkExpr 2 |- \ a -> g a : (a : F true (\ x -> unit)) -> Bool
/// checkForced fromList [(g,1),(F,0)] |- \ a -> g a : (a : F true (\ x -> unit)) -> Bool
/// new a : (v0 {true {g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}} {\ x -> unit {g = (v1 Up ((v0 {false {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}} {\ x -> x {F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}})::Tm -> Bool{F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))})), F = (v0 Up (.[b : Bool::Tm] -> (U b -> U b) -> Set))}})
/// checkExpr 3 |- g a : Bool
/// inferExpr' g a
/// leqVal' (subtyping)  < a : F true (\ x -> unit) >  <=+  F false (\ x -> x)
/// leqVal' (subtyping)  F true (\ x -> unit)  <=+  F false (\ x -> x)
/// leqVal'  \ x -> unit : Unit -> U true  <=*  \ x -> x : Bool -> U false
/// new x : Unit||Bool
/// leqVal'  unit : Unit  <=*  x : Bool
/// type Unit has different shape than Bool
