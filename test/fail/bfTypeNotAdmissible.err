MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "bfTypeNotAdmissible.ma" ---
--- scope checking ---
--- type checking ---
type  Prod : ++(A : Set) -> ++(B : Set) -> Set
term  pair : .[A : Set] -> .[B : Set] -> ^(y0 : A) -> ^(y1 : B) -> < pair y0 y1 : Prod A B >
type  Prod : ++(A : Set) -> ++(B : Set) -> Set
term  split : .[A : Set] -> .[B : Set] -> Prod A B -> .[C : Set] -> (A -> B -> C) -> C
{ split [A] [B] (pair a b) [C] f = f a b
}
type  List : ++(A : Set) -> + Size -> Set
term  nil : .[A : Set] -> .[s!ze : Size] -> .[i < s!ze] -> List A s!ze
term  nil : .[A : Set] -> .[i : Size] -> < nil i : List A $i >
term  cons : .[A : Set] -> .[s!ze : Size] -> .[i < s!ze] -> ^ A -> ^ List A i -> List A s!ze
term  cons : .[A : Set] -> .[i : Size] -> ^(y1 : A) -> ^(y2 : List A i) -> < cons i y1 y2 : List A $i >
type  List : ++(A : Set) -> + Size -> Set
term  append : .[A : Set] -> List A # -> List A # -> List A #
{ append [A] (nil [.#]) l = l
; append [A] (cons [.#] a as) l = cons [#] a (append [A] as l)
}
type  Rose : ++(A : Set) -> + Size -> Set
term  rose : .[A : Set] -> .[s!ze : Size] -> .[i < s!ze] -> ^ A -> ^ List (Rose A i) # -> Rose A s!ze
term  rose : .[A : Set] -> .[i : Size] -> ^(y1 : A) -> ^(y2 : List (Rose A i) #) -> < rose i y1 y2 : Rose A $i >
type  Rose : ++(A : Set) -> + Size -> Set
term  step : .[j : Size] -> .[A : Set] -> .[i : Size] -> List (Rose A $i) j -> Prod (List A j) (List (Rose A i) #)
{ step [.$j] [A] [i] (nil [j]) = pair (nil [j]) (nil [#])
; step [.$j] [A] [.i] (cons [j] (rose [i] a rs') rs) = split [List A j] [List (Rose A i) #] (step [j] [A] [i] rs) [Prod (List A $j) (List (Rose A i) #)] (\ as -> \ rs'' -> pair (cons [j] a as) (append [Rose A i] rs' rs''))
}
term  bf' : .[A : Set] -> .[i : Size] -> List A # -> List (Rose A i) # -> List A #
error during typechecking:
checking type of bf' for admissibility
/// new A : _
/// new as : _
/// new i : _
/// new a : _
/// new r : _
/// new rs : _
/// new i : Size
/// admType: checking ((List v0 {# {i = v6, A = v0}})::Tm -> List (Rose A i) # -> List A #{i = v6, A = v0}) admissible in v6
/// new  : (List v0 {# {i = v6, A = v0}})
/// admType: checking ((List {Rose A i {i = v6, A = v0}} {# {i = v6, A = v0}})::Tm -> List A #{i = v6, A = v0}) admissible in v6
/// type (List {Rose A i {i = v6, A = v0}} {# {i = v6, A = v0}}) not lower semi continuous in v6
