MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "InjDataLoop.ma" ---
--- scope checking ---
--- type checking ---
type  Empty : Set
type  Empty : Set
type  Eq : .[i : Size] -> ^(A : Set i) -> ^(a : A) -> ^ A -> Set
term  refl : .[i : Size] -> .[A : Set i] -> .[a : A] -> Eq [i] A a a
type  Eq : .[i : Size] -> ^(A : Set i) -> ^(a : A) -> ^ A -> Set
type  I : ^(F : Set -> Set) -> Set
type  I : ^(F : Set -> Set) -> Set
ty-u  InvI : ^(A : Set) -> Set $0
term  inv : .[A : Set] -> ^(Inverse : Set -> Set) -> ^ Eq [$0] Set (I Inverse) A -> InvI A
ty-u  InvI : ^(A : Set) -> Set $0
tmty  invertible : (A : Set) -> InvI A
{}
type  cantor : Set -> Set
type  cantor = \ A -> case _invertible A
       { inv [.A] X p -> X A -> Empty
       }
type  cIc : Set
type  cIc = cantor (I cantor)
error during typechecking:
delta
/// checkExpr 0 |- case _invertible (I cantor)
               { inv .(I cantor) .cantor (refl .$0 .Set .(I cantor)) -> \ f -> f f
               } : case invertible (I cantor)
                   { inv [.I cantor] X p -> (~2 : X (I cantor)) -> Empty
                   }
/// case 1
/// dot pattern I cantor
/// inferred value I .(cantor) does not match given dot pattern value I cantor
/// leqVal' [(".($0)",2),(".(I cantor)",4),(".(Set)",3),(".(cantor)",1)] |- I .(cantor)  <=+  I cantor : Set
/// leqVal' [(".($0)",2),(".(I cantor)",4),(".(Set)",3),(".(cantor)",1)] |- .(cantor)  <=^  \ A -> case _invertible A
                                                                                               { inv [.A] X p -> (~8 : X A) -> Empty
                                                                                               } : (~5 : Set) -> Set
/// new  : Set
/// leqVal' [("",5),(".($0)",2),(".(I cantor)",4),(".(Set)",3),(".(cantor)",1)] |- .(cantor) ~5  <=^  case invertible ~5
                                                                                                  { inv [.~5] X p -> (~8 : X ~5) -> Empty
                                                                                                  } : Set
/// leqApp: (v1 v5)[] !<= case (invertible v5){ (inv [.A] X p) -> X A -> Empty } {A = v5}[]
