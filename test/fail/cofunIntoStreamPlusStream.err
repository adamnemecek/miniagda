MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "cofunIntoStreamPlusStream.ma" ---
--- scope checking ---
--- type checking ---
type  Unit : Set
term  unit : Unit
type  Unit : Set
type  Bool : Set
term  true : Bool
term  false : Bool
type  Bool : Set
type  Twice : ++(A : Set) -> Set
term  inl : .[A : Set] -> ^ A -> Twice A
term  inr : .[A : Set] -> ^ A -> Twice A
type  Twice : ++(A : Set) -> Set
term  fmap : .[A : Set] -> .[B : Set] -> (A -> B) -> Twice A -> Twice B
{ fmap [A] [B] f (inl [.A] a) = inl [B] (f a)
; fmap [A] [B] f (inr [.A] a) = inr [B] (f a)
}
type  BStr : - Size -> Set
term  cons : .[i : Size] -> ^(head : Bool) -> ^(tail : BStr i) -> BStr $i
type  BStr : - Size -> Set
G> fun head : .[i : Size] -> (__cons : BStr $i) -> Bool
G> { head i (cons .i __head __tail) = __head
}
term  head : .[i : Size] -> (__cons : BStr $i) -> Bool
{ head [i] (cons [.i] __head __tail) = __head
}
G> fun tail : .[i : Size] -> (__cons : BStr $i) -> BStr i
G> { tail i (cons .i __head __tail) = __tail
}
term  tail : .[i : Size] -> (__cons : BStr $i) -> BStr i
{ tail [i] (cons [.i] __head __tail) = __tail
}
term  idAndLast : .[i : Size] -> BStr i -> Twice (BStr i)
error during typechecking:
idAndLast
/// clause 1
/// pattern $i
/// checkPattern $i : matching on size, checking that target .[i : Size] -> (~1 : BStr i) -> Twice (BStr i) ends in correct coinductive sized type
/// new i : Size
/// endsInSizedCo: (~1 : BStr i) -> Twice (BStr i)
/// new  : (BStr v0)
/// endsInSizedCo: Twice (BStr i)
/// endsInSizedCo: target Twice (BStr i) of corecursive function is neither a CoSet or codata of size i nor a tuple type
