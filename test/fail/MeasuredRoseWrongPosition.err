MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "MeasuredRoseWrongPosition.ma" ---
--- scope checking ---
--- type checking ---
type  List : ++(A : Set) -> Set
term  nil : .[A : Set] -> < nil : List A >
term  cons : .[A : Set] -> ^(y0 : A) -> ^(y1 : List A) -> < cons y0 y1 : List A >
term  mapList : .[A : Set] -> .[B : Set] -> (A -> B) -> List A -> List B
{ mapList [A] [B] f (nil) = nil
; mapList [A] [B] f (cons a as) = cons (f a) (mapList [A] [B] f as)
}
type  Rose : ++(A : Set) -> + Size -> Set
term  rose : .[A : Set] -> .[s!ze : Size] -> .[i < s!ze] -> ^ A -> ^ List (Rose A i) -> Rose A s!ze
term  rose : .[A : Set] -> .[i : Size] -> ^(y1 : A) -> ^(y2 : List (Rose A i)) -> < rose i y1 y2 : Rose A $i >
term  mapRose : .[A : Set] -> .[B : Set] -> (A -> B) -> .[i : Size] -> Rose A i -> Rose B i
error during typechecking:
mapRose
/// clause 1
/// right hand side
/// checkExpr 7 |- rose j (f a) (mapList (Rose A j) (Rose B j) (mapRose A B f j) rs) : Rose B i
/// checkForced fromList [(B,1),(A,0),(f,2),(i,3),(j,4),(a,5),(rs,6)] |- rose j (f a) (mapList (Rose A j) (Rose B j) (mapRose A B f j) rs) : Rose B i
/// inferExpr' mapList (Rose A j) (Rose B j) (mapRose A B f j) rs
/// inferExpr' mapList (Rose A j) (Rose B j) (mapRose A B f j)
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(j,4),(a,5),(rs,6)] |- (xSing# : Rose A j) -> < mapRose [A] [B] f [j] xSing# : |j| -> Rose B j >  <=+  Rose A j -> Rose B j
/// new xSing# : (Rose v0 v4)||(Rose v0 v4)
/// comparing codomain < vSing# xSing# : |i| -> Rose B i > with B
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(j,4),(a,5),(rs,6),(xSing#,7)] |- < mapRose [A] [B] f [j] xSing# : |j| < |i| -> Rose B j >  <=+  Rose B j
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(j,4),(a,5),(rs,6),(xSing#,7)] |- |j| < |i| -> Rose B j  <=+  Rose B j
/// leqApp: (|v4| < |v3| -> (Rose v1 v4))[] !<=+ (Rose v1 v4)[]
