MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "MeasuredRoseWrongPosition.ma" ---
--- scope checking ---
--- type checking ---
type  List : ++(A : Set) -> Set
term  nil : .[A : Set] -> List A
term  cons : .[A : Set] -> ^ A -> ^ List A -> List A
type  List : ++(A : Set) -> Set
term  mapList : .[A : Set] -> .[B : Set] -> (A -> B) -> List A -> List B
{ mapList [A] [B] f (nil [.A]) = nil [B]
; mapList [A] [B] f (cons [.A] a as) = cons [B] (f a) (mapList [A] [B] f as)
}
type  Rose : ++(A : Set) -> + Size -> Set
term  rose : .[A : Set] -> .[i : Size] -> ^ A -> ^ List (Rose A i) -> Rose A $i
type  Rose : ++(A : Set) -> + Size -> Set
term  mapRose : .[A : Set] -> .[B : Set] -> (A -> B) -> .[i : Size] -> Rose A i -> Rose B i
error during typechecking:
mapRose
/// clause 1
/// right hand side
/// checkExpr 8 |- rose B j (f a) (mapList (Rose A j) (Rose B j) (mapRose A B f j) rs) : Rose B i
/// inferExpr' rose B j (f a) (mapList (Rose A j) (Rose B j) (mapRose A B f j) rs)
/// inferExpr' mapList (Rose A j) (Rose B j) (mapRose A B f j) rs
/// inferExpr' mapList (Rose A j) (Rose B j) (mapRose A B f j)
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(.A,4),(j,5),(a,6),(rs,7)] |- (xSing# : Rose A j) -> < mapRose [A] [B] f [j] xSing# : |j| -> Rose B j >  <=+  Rose A j -> Rose B j
/// new xSing# : (Rose v0 v5)||(Rose v0 v5)
/// comparing codomain < vSing# xSing# : |i| -> Rose B i > with B
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(.A,4),(j,5),(a,6),(rs,7),(xSing#,8)] |- < mapRose [A] [B] f [j] xSing# : |j| < |i| -> Rose B j >  <=+  Rose B j
/// leqVal' (subtyping) [(B,1),(A,0),(f,2),(i,3),(.A,4),(j,5),(a,6),(rs,7),(xSing#,8)] |- |j| < |i| -> Rose B j  <=+  Rose B j
/// leqApp: (|v5| < |v3| -> (Rose v1 v5))[] !<= (Rose v1 v5)[]
