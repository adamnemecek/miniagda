MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "StreamNotSemiCont.ma" ---
--- scope checking ---
--- type checking ---
type  Unit : Set
term  unit : < unit : Unit >
type  Unit : Set
type  Stream : +(A : Set) -> - Size -> Set
term  cons : .[A : Set] -> .[i : Size] -> ^(head : A) -> ^(tail : Stream A i) -> < cons i head tail : Stream A $i >
type  Stream : +(A : Set) -> - Size -> Set
G> fun head : .[A : Set] -> .[i : Size] -> (cons : Stream A $i) -> A
G> { head A i (cons .i destructor_argument_head destructor_argument_tail) = destructor_argument_head
}
term  head : .[A : Set] -> .[i : Size] -> (cons : Stream A $i) -> A
{ head [A] [i] (cons [.i] destructor_argument_head destructor_argument_tail) = destructor_argument_head
}
G> fun tail : .[A : Set] -> .[i : Size] -> (cons : Stream A $i) -> Stream A i
G> { tail A i (cons .i destructor_argument_head destructor_argument_tail) = destructor_argument_tail
}
term  tail : .[A : Set] -> .[i : Size] -> (cons : Stream A $i) -> Stream A i
{ tail [A] [i] (cons [.i] destructor_argument_head destructor_argument_tail) = destructor_argument_tail
}
term  bad : .[i : Size] -> .[A : Set] -> (Stream A i -> Stream A i) -> Stream A i
error during typechecking:
bad
/// clause 1
/// pattern $i
/// checkPattern $i : matching on size, checking that target .[i : Size] -> .[A : Set] -> (Stream A i -> Stream A i) -> Stream A i ends in correct coinductive sized type
/// new i : Size
/// endsInSizedCo: .[A : Set] -> (Stream A i -> Stream A i) -> Stream A i
/// new A : Set
/// endsInSizedCo: (Stream A i -> Stream A i) -> Stream A i
/// new  : ((Stream v1 v0)::Tm -> Stream A i{A = v1, i = v0})
/// type Stream A i -> Stream A i not lower semi continuous in i
