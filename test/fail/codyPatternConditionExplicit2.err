MiniAgda by Andreas Abel and Karl Mehltretter
--- opening "codyPatternConditionExplicit2.ma" ---
--- scope checking ---
--- type checking ---
type  Nat : Set
term  zero : < zero : Nat >
term  succ : ^(y0 : Nat) -> < succ y0 : Nat >
type  O : + Size -> Set
term  Z : .[s!ze : Size] -> .[i < s!ze] -> O s!ze
term  Z : .[i : Size] -> < Z i : O $i >
term  S : .[s!ze : Size] -> .[i < s!ze] -> ^ O i -> O s!ze
term  S : .[i : Size] -> ^(y1 : O i) -> < S i y1 : O $i >
term  L : .[s!ze : Size] -> .[i < s!ze] -> ^ (Nat -> O i) -> O s!ze
term  L : .[i : Size] -> ^(y1 : Nat -> O i) -> < L i y1 : O $i >
term  M : .[s!ze : Size] -> .[i < s!ze] -> ^ O i -> ^ O i -> O s!ze
term  M : .[i : Size] -> ^(y1 : O i) -> ^(y2 : O i) -> < M i y1 y2 : O $i >
term  f01 : .[i : Size] -> Nat -> O $$$i
{ f01 [i] zero = Z [i]
; f01 [i] (succ zero) = S [$i] (Z [i])
; f01 [i] (succ (succ n)) = S [$$i] (S [$i] (Z [i]))
}
term  v5 : .[i : Size] -> O $$$$$i
term  v5 = [\ i ->] M [$$$$i] (L [$$$i] (f01 [i])) (S [$$$i] (S [$$i] (S [$i] (Z [i]))))
term  emb : Nat -> O #
{ emb zero = Z [#]
; emb (succ n) = S [#] (emb n)
}
term  pre : .[i : Size] -> (Nat -> O $$i) -> Nat -> O $i
term  pre = [\ i ->] \ f -> \ n -> case f (succ n) : O $$i
                       { Z [.$i] -> Z [i]
                       ; S [.$i] x -> x
                       ; L [.$i] g -> g n
                       ; M [.$i] a b -> a
                       }
term  deep : .[i : Size] -> O i -> Nat -> Nat
error during typechecking:
deep
/// clause 1
/// right hand side
/// checkExpr 9 |- deep (max $$$i $$j2) (M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n))) (succ (succ (succ n))) : Nat
/// inferExpr' deep (max $$$i $$j2) (M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n))) (succ (succ (succ n)))
/// inferExpr' deep (max $$$i $$j2) (M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n)))
/// checkApp ((O (max ($ ($ ($ v6))) ($ ($ v2))))::Tm -> Nat -> Nat{i = (max ($ ($ ($ v6))) ($ ($ v2)))}) eliminated by M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n))
/// checkExpr 9 |- M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n)) : O (max $$$i $$j2)
/// checkForced fromList [(i4,0),(i3,1),(j2,2),(f,3),(i2,4),(i1,5),(i,6),(x,7),(n,8)] |- M (max $$i $j2) (L $i (pre $$i f)) (S j2 (f n)) : O (max $$$i $$j2)
/// checkApp (^(y1 : (O (max ($ ($ v6)) ($ v2)))::()) -> ^(y2 : O i) -> < M i y1 y2 : O $i >{i = (max ($ ($ v6)) ($ v2))}) eliminated by L $i (pre $$i f)
/// checkExpr 9 |- L $i (pre $$i f) : O (max $$i $j2)
/// checkForced fromList [(i4,0),(i3,1),(j2,2),(f,3),(i2,4),(i1,5),(i,6),(x,7),(n,8)] |- L $i (pre $$i f) : O (max $$i $j2)
/// checkApp (^(y1 : (Nat::Tm -> O i{i = ($ v6)})::()) -> < L i y1 : O $i >{i = ($ v6)}) eliminated by pre $$i f
/// inferExpr' pre $$i f
/// checkApp ((Nat::Tm -> O $$i{i = ($ ($ v6))})::Tm -> Nat -> O $i{i = ($ ($ v6))}) eliminated by f
/// leqVal' (subtyping)  (xSing# : Nat) -> < f xSing# : O j2 >  <=+  Nat -> O $$$$i
/// new xSing# : Nat
/// comparing codomain < vSing# xSing# : O i > with O $$i
/// leqVal' (subtyping)  < f xSing# : O j2 >  <=+  O $$$$i
/// leqVal' (subtyping)  O j2  <=+  O $$$$i
/// leqVal'  j2  <=+  $$$$i : <= #
/// leSize j2 <=+ $$$$i
/// leSize' j2 <= $$$$i
/// bound not entailed
