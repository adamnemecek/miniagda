\nonstopmode
\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm, amssymb}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{pxfonts}
\usepackage[german,english]{babel} 

\pagestyle{headings}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}

\newenvironment{bsp}
{\begin{list}{}{
\setlength{\leftmargin}{0cm}
\setlength{\rightmargin}{0cm}
}\item}{
\end {list}
}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\newcommand{\vex}[1]{\overrightarrow{#1}} 
\newcommand{\ves}[1]{{#1}^{\ast}} 

\newcommand{\vsp}{\:\vert\:}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\s}{\mathsf{s}\,}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\EPi}[2]{( #1 : #2 ) \rightarrow} 
\newcommand{\data}{\mathsf{data}\:}
\newcommand{\sized}{\mathsf{sized}\:}
\newcommand{\fun}{\mathsf{fun}\:}
\newcommand{\codata}{\mathsf{codata}\:}
\newcommand{\cofun}{\mathsf{cofun}\:}
\newcommand{\clet}{\mathsf{let}\:}
\newcommand{\ELet}[3]{\mathsf{let}\: #1 : #2 = #3 \: \mathsf{in}\:} 
\newcommand{\mutual}{\mathsf{mutual}\:}
\newcommand{\lam}[1]{\lambda\: #1 .\:}

\newcommand{\inacc}[1]{\underline{#1}}

\newcommand{\id}{\mathsf{id}\:}
\newcommand{\Nat}{\mathsf{Nat}\:}
\newcommand{\zero}{\mathsf{zero}\:}
\newcommand{\suc}{\mathsf{succ}\:}
\newcommand{\add}{\mathsf{add}\:}
\newcommand{\addt}{\mathsf{add_2}\:}

\newcommand{\Vd}{\mathsf{V}\:}
\newcommand{\vc}{\mathsf{v}\:}

\newcommand{\NatP}{\mathsf{NatPair}\:}
\newcommand{\np}{\mathsf{np}\:}
\newcommand{\addp}{\mathsf{add_p}\:}

\newcommand{\even}{\mathsf{even}\:}
\newcommand{\odd}{\mathsf{odd}\:}

\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\ttt}{\mathsf{tt}\:}
\newcommand{\fff}{\mathsf{ff}\:}

\newcommand{\List}{\mathsf{List}\:}
\newcommand{\Lists}{\mathsf{List}}
\newcommand{\nil}{\mathsf{nil}\:}
\newcommand{\cons}{\mathsf{cons}\:}

\newcommand{\Term}{\mathsf{Term}\:}
\newcommand{\Terms}{\mathsf{Term}}
\newcommand{\abs}{\mathsf{abs}\:}
\newcommand{\funt}{\mathsf{Fun}\:}
\newcommand{\func}{\mathsf{fn}\:}
\newcommand{\omegad}{\mathsf{omega}\:}
\newcommand{\app}{\mathsf{app}\:}

\newcommand{\Tree}{\mathsf{Tree}\:}
\newcommand{\leaf}{\mathsf{leaf}\:}
\newcommand{\node}{\mathsf{node}}

\newcommand{\vVec}{\mathsf{Vec}\:}
\newcommand{\head}{\mathsf{head}\:}

\newcommand{\heads}{\mathsf{head}}

\newcommand{\rev}{\mathsf{rev}\:}
\newcommand{\revs}{\mathsf{rev}}
\newcommand{\reva}{\mathsf{rev_1}\:}
\newcommand{\revb}{\mathsf{rev_2}\:}


\newcommand{\flatt}{\mathsf{flat}\:}

\newcommand{\Eq}{\mathsf{Eq}\:}
\newcommand{\refl}{\mathsf{refl}\:}

\newcommand{\prof}{\mathsf{proof}\:}
\newcommand{\tprof}{\mathsf{proof_2}\:}
\newcommand{\eqsucc}{\mathsf{eqSucc}\:}

\newcommand{\bad}{\mathsf{bad_1}\:}
\newcommand{\badb}{\mathsf{bad_2}\:}


\newcommand{\ProdT}{\mathsf{Prod}\:}
\newcommand{\prd}{\mathsf{prod}\:}
\newcommand{\pra}{\mathsf{pr_1}\:}
\newcommand{\prb}{\mathsf{pr_2}\:}
\newcommand{\quicksort}{\mathsf{quicksort}\:}
\newcommand{\qsapp}{\mathsf{qsapp}\:}
\newcommand{\pivot}{\mathsf{split}\:}
\newcommand{\lleq}{\mathit{leq}\:}
\newcommand{\ite}{\mathsf{ite}\:}

\newcommand{\Ord}{\mathsf{Ord}\:}
\newcommand{\Ords}{\mathsf{Ord}}

\newcommand{\ozero}{\mathsf{ozero}\:}
\newcommand{\olim}{\mathsf{olim}\:}
\newcommand{\addOrd}{\mathsf{addOrd}\:}

\newcommand{\Stream}{\mathsf{Stream}\:}
\newcommand{\Streams}{\mathsf{Stream}}
\newcommand{\tail}{\mathsf{tail}\:}
\newcommand{\nth}{\mathsf{nth}\:}

\newcommand{\wkSNat}{\mathsf{weakSNat}\:}
\newcommand{\wkSNatb}{\mathsf{badSNat}\:}
\newcommand{\wkStream}{\mathsf{weakStream}\:}


\newcommand{\minus}{\mathsf{minus}\:}
\renewcommand{\div}{\mathsf{div}\:}

\newcommand{\SNat}{\mathsf{Nat}\:}
\newcommand{\SList}{\mathsf{List}\:}
\newcommand{\SStream}{\mathsf{Stream}\:}
\newcommand{\SStreams}{\mathsf{Stream}}
\newcommand{\SOrd}{\mathsf{Ord}\:}

\newcommand{\filter}{\mathsf{filter}}
\newcommand{\tLeq}{\mathsf{Leq}\:}

\newcommand{\Maybe}{\mathsf{Maybe}\:}
\newcommand{\nothing}{\mathsf{nothing}\:}
\newcommand{\just}{\mathsf{just}\:}
\newcommand{\shift}{\mathsf{shift}\:}
\newcommand{\shiftcase}{\mathsf{shift\_case}\:}
\newcommand{\inc}{\mathsf{inc}\:}
\newcommand{\lop}{\mathsf{loop}\:}
\newcommand{\lopcase}{\mathsf{loop\_case}\:}
\newcommand{\diverge}{\mathsf{diverge}\:}

\newcommand{\zeroes}{\mathsf{zeroes}\:}
\newcommand{\unp}{\mathsf{unp}\:}
\newcommand{\zipWith}{\mathsf{zipWith}\:}
\newcommand{\fibs}{\mathsf{fib'}\:}
\newcommand{\fib}{\mathsf{fib}\:}
\newcommand{\fibf}{\mathsf{fib4}\:}

\newcommand{\Empty}{\mathsf{Empty}\:}
\newcommand{\BadNat}{\mathsf{BadNat}\:}
\newcommand{\foo}{\mathsf{foo}\:}

\newcommand{\addWith}{\mathsf{addWith}\:}

\newcommand{\ispd}{\mathsf{ISP}\:}
\newcommand{\spd}{\mathsf{SP}\:}
\newcommand{\putd}{\mathsf{put}\:}
\newcommand{\getd}{\mathsf{get}\:}
\newcommand{\isp}{\mathsf{isp}\:}
\newcommand{\ieat}{\mathsf{ieat}\:}
\newcommand{\eat}{\mathsf{eat}\:}

\newcommand{\adder}{\mathsf{adder}\:}
\newcommand{\cadder}{\mathsf{coadder}\:}
\newcommand{\iadder}{\mathsf{iadder}\:}

\newcommand{\eqo}{\mathsf{isEq}\:}
\newcommand{\zeroest}{\mathsf{zeroes_2}\:}
\newcommand{\beqd}{\mathsf{Bis}\:}
\newcommand{\beq}{\mathsf{bis}\:}
\newcommand{\eqt}{\mathsf{isBis}\:}

\newcommand{\ra}{\rightarrow}

\newcommand{\spc}{\hspace*{3mm}}
\newcommand{\spcx}{\hspace*{10mm}}
\newcommand{\vs}{\vspace*{1mm}}

\newcommand{\mugda}{\textsf{Mugda} }


\selectlanguage{german}

\begin{document}
\begin{titlepage}

\begin{center}

{\Huge INSTITUT F\"UR INFORMATIK\\[1mm]} % 
DER LUDWIG--MAXIMILIANS--UNIVERSIT\"AT M\"UNCHEN\\

\vspace*{1cm}

\includegraphics[width=0.35\textwidth]{siegel.pdf}

\vspace*{2cm}

{\LARGE \textbf{Diplomarbeit}}\\

\vspace{2.0cm}
{\LARGE \textbf{TERMINATION CHECKING FOR A}}\\
\vspace*{3mm}
{\LARGE \textbf{DEPENDENTLY TYPED LANGUAGE}}\\

\vspace{2cm}

\Large{Dezember 2007}

\vspace{1.5cm}

  \begin{Large}
  \begin{tabular}{rl}
      Autor: &Karl Mehltretter\\
      Aufgabensteller: & Prof. Martin Hofmann\\
      Betreuer: & Dr. Andreas Abel\\
  \end{tabular}
  \end{Large}

\end{center}

\end{titlepage} 

\input{legal}

\bibliographystyle{alpha}





\title{Termination Checking for a dependently typed language}
\author{Karl Mehltretter}
\date{today}
\renewcommand{\abstractname}{Inhalt}
\begin{abstract}
Abh\"angige Typen werden als Basis f\"ur viele interaktive Theorembeweiser eingesetzt und es gibt seit einiger Zeit Bem\"uhungen, sie f\"ur allgemeine funktionale Programmiersprachen zu verwenden.
Eine Sprache mit abh\"angigen Typen erlaubt es, in einem gemeinsamen Rahmen sowohl Programme zu schreiben als auch Beweise zu formalisieren.

Das aus der Programmierung bekannte \emph{pattern matching} wurde als Mittel zur Definition von
rekursiven Funktionen in diesen Systemen vorgeschlagen.
Zwar ist pattern matching intuitiv und ausdrucksstark, doch muss sicher\-gestellt werden, dass die so definierten Funktionen total sind.

Ein Aspekt einer totalen Funktion ist Terminierung: Jeder Auswertung der Funktion muss in endlicher Zeit m\"oglich sein.  Unendliche Objekte k\"onnen unterst\"utzt werden, indem jeweils nur Teile davon berechnet werden.
G\"ultige Definitionen f\"ur unendliche Objekte m\"ussen \emph{produktiv} sein.

Da das Halteproblem unentscheidbar ist, kann das Ziel nur sein, m\"og\-lichst viele Definition als terminierend zu erkennen. Es gibt verschiedene Ans\"atze zum \"Uberpr\"ufen der Terminierung.
Oft k\"onnen Funktionen, deren rekursive Aufrufe einem gewissen Schema folgen,
 vom System zugelassen werden. Das \emph{size-change principle} umfasst einige dieser Schemata. 

Ein weiterer Vorschlag ist der Einsatz von \emph{sized types}. Information \"uber die Gr\"o\ss e von Argumenten wird im Typsystem verfolgt, um diese f\"ur das Erkennen der Terminierung zu nutzen.   

Im Rahmen dieser Diplomarbeit wurde das System \mugda ent\-wickelt und wird nachfolgend vorgestellt.
Es basiert auf Typentheorie nach Martin-L\"of und unterst\"utzt induktive und coinduktive Typen. Rekursive Funktionen werden  durch pattern matching definiert.
Das Kriterium f\"ur Terminierung basiert auf dem \emph{size-change principle}.
Au\ss erdem stellt die Sprache Elemente bereit, um dem Benutzer die Verwendung von \emph{sized types} zu erm\"oglichen.
\end{abstract}
\newpage

\selectlanguage{english} 
\renewcommand{\abstractname}{Abstract}
\begin{abstract}
Dependent types have been used at the core of many proof assistants, and more recently there have been efforts to extend their use to functional programming languages. 
Dependent type theories allow programming and reasoning in a common framework.

The \emph{pattern matching} notation, known from traditional programming, has been proposed for defining recursive functions in such systems.
While pattern matching is intuitive and powerful, it has to be ensured that the defined functions are total. 

One aspect of totality is termination: the evaluation of a function at any argument must be computable in finite time.
Infinite objects can be added to the language by computing only finite parts of them as necessary.
Valid definitions of infinite objects need to be \emph{productive}. 

As the halteproblem is undecidable, the goal can only be to accept as many valid definitions as possible.
There are many approaches to ensure termination.
One is to allow the definition of functions where the recursive calls follow a certain scheme.
The \emph{size-change principle} subsumes some of these schemes.

Another approach is the use of \emph{sized types}, where information about the height of arguments is tracked in the type system and is used to recognize definitions as terminating.  

For this thesis, the system \mugda was developed and will subsequently be described. It is based on \emph{Martin-L\"of type theory} and supports inductive and coinductive types. Recursive functions are defined by pattern matching. Its termination criterion is based on the size-change principle. In  addition, the language provides elements to enable the use of sized types.

\end{abstract}
\tableofcontents
\input{intro}
\input{main}
\input{concl}
\input{appendix}
\input{bibl}

\end{document}