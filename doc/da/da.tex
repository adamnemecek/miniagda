
\documentclass[a4paper,11pt]{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{subfig}
\usepackage{proof}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}

\newenvironment{bsp}
{\begin{list}{}{
\setlength{\leftmargin}{0cm}
\setlength{\rightmargin}{0cm}
}
\item}{
\end {list}
}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\renewcommand\vec[1]{\overrightarrow{#1}} 

\newcommand{\vsp}{\;\vert\;}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\s}{\mathsf{s}\;}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\EPi}[2]{( #1 : #2 ) \rightarrow} 
\newcommand{\data}{\mathrm{data}\;}
\newcommand{\fun}{\mathrm{fun}\;}
\newcommand{\codata}{\mathrm{codata}\;}
\newcommand{\cofun}{\mathrm{cofun}\;}
\newcommand{\norec}{\mathrm{norec}\;}
\newcommand{\const}{\mathrm{const}\;}
\newcommand{\mutual}{\mathrm{mutual}\;}
\newcommand{\lam}[1]{\lambda\; #1 .\;}

\newcommand{\inacc}[1]{\underline{#1}}

\newcommand{\id}{\mathsf{id}\;}
\newcommand{\Nat}{\mathsf{Nat}\;}
\newcommand{\zero}{\mathsf{zero}\;}
\newcommand{\suc}{\mathsf{succ}\;}
\newcommand{\add}{\mathsf{add}\;}

\newcommand{\Bool}{\mathsf{Bool}\;}
\newcommand{\ttt}{\mathsf{tt}\;}
\newcommand{\fff}{\mathsf{ff}\;}

\newcommand{\List}{\mathsf{List}\;}
\newcommand{\nil}{\mathsf{nil}\;}
\newcommand{\cons}{\mathsf{cons}\;}


\newcommand{\Tree}{\mathsf{Tree}\;}
\newcommand{\leaf}{\mathsf{leaf}\;}
\newcommand{\node}{\mathsf{node}\;}

\newcommand{\vVec}{\mathsf{Vec}\;}
\newcommand{\head}{\mathsf{head}\;}
\newcommand{\rev}{\mathsf{rev}\;}
\newcommand{\reva}{\mathsf{rev1}\;}
\newcommand{\revb}{\mathsf{rev2}\;}

\newcommand{\Eq}{\mathsf{Eq}\;}
\newcommand{\refl}{\mathsf{refl}\;}

\newcommand{\prof}{\mathsf{proof}\;}
\newcommand{\tprof}{\mathsf{proof2}\;}
\newcommand{\eqsucc}{\mathsf{eqsucc}\;}

\newcommand{\Bad}{\mathsf{Bad}\;}
\newcommand{\bad}{\mathsf{bad}\;}
\newcommand{\ok}{\mathsf{ok}\;}

\newcommand{\ProdT}{\mathsf{Prod}\;}
\newcommand{\prd}{\mathsf{prod}\;}
\newcommand{\pra}{\mathsf{pr_1}\;}
\newcommand{\prb}{\mathsf{pr_2}\;}
\newcommand{\quicksort}{\mathsf{quicksort}\;}
\newcommand{\qsapp}{\mathsf{qsapp}\;}
\newcommand{\pivot}{\mathsf{split}\;}
\newcommand{\lleq}{\mathit{leq}\;}
\newcommand{\ite}{\mathsf{ite}\;}

\newcommand{\Ord}{\mathsf{Ord}\;}
\newcommand{\ozero}{\mathsf{ozero}\;}
\newcommand{\olim}{\mathsf{olim}\;}
\newcommand{\addOrd}{\mathsf{addOrd}\;}

\newcommand{\Stream}{\mathsf{Stream}\;}
\newcommand{\tail}{\mathsf{tail}\;}
\newcommand{\nth}{\mathsf{nth}\;}

\newcommand{\ones}{\mathsf{ones}\;}
\newcommand{\unp}{\mathsf{unp}\;}
\newcommand{\zipWith}{\mathsf{zipWith}\;}
\newcommand{\fib}{\mathsf{fib}\;}
\newcommand{\fibf}{\mathsf{fib4}\;}

\newcommand{\Empty}{\mathsf{Empty}\;}
\newcommand{\BadNat}{\mathsf{BadNat}\;}
\newcommand{\foo}{\mathsf{foo}\;}


\newcommand{\ra}{\rightarrow}

\newcommand{\spc}{\hspace*{3mm}}
\newcommand{\spcx}{\hspace*{10mm}}
\newcommand{\vs}{\vspace{2mm}}
\newtheorem{definition}{Definition}

\begin{document}
\begin{titlepage}
\begin{center}


\vspace*{-2cm}

{\Huge INSTITUT F\"UR INFORMATIK\\[1mm]} % 
DER LUDWIG--MAXIMILIANS--UNIVERSIT\"AT M\"UNCHEN\\

\vspace*{1cm}

\includegraphics[width=0.4\textwidth]{siegel.pdf}

\vspace*{2cm}

{\Large \textbf{Diplomarbeit}}\\

\vspace{2.0cm}
{\Huge \textbf{Termination Checking for a}}\\
\vspace*{3mm}
{\Huge \textbf{dependently typed language}}\\

\vspace{2cm}

\large{Dezember 2007}

\vspace{1.5cm}

  \begin{Large}
      Autor : Karl Mehltretter\\
      Aufgabensteller : Prof. Dr. Martin Hofmann\\
      Betreuer: Dr. Andreas Abel
  \end{Large}

\end{center}
\end{titlepage} 

\input{legal}

\title{Termination Checking for a dependently typed language}
\author{Karl Mehltretter}
\date{today}
\renewcommand{\abstractname}{Abstrakt}
\begin{abstract}
Abh\"angige Typen werden seit langer Zeit als Basis f\"ur viele Theorembeweiser eingesezt.
Seit kurzem gibt es auch Bem\"uhungen, sie f\"ur allgemeine Programmiersprachen zu verwenden.
Abh\"angige Typen erlauben das Erstellen von Programmen und Beweise darueber in einem gemeinsamen Rahmen.

Das aus der funktionalen Programmierung bekannte pattern matching wurde als Mittel zur Definition von
rekursiven Funktionen in diesen Systemen vorgeschlagen.
Doch erlaubt pattern matching die Definition von nicht-terminierenden Funktionen, was bei Systemen mit abh\"angin Tpen nicht erlaubt ist.

Es ist bekannt, dass das Halteproblem im allgemeinen Unentscheidbar ist. 
Deswegen wird es nie einen perfekten Termination-Checker geben. Es wird Definition geben, die korrekt terminieren aber zur\\"uckgewiesen werden.
Viele Methoden wurden vorgeschlagen, um eine m\"oglichst grosse Anzahl g\"ultiger Definitionen zuzulassen.

Das Ziel dieser Arbeit war, diese Methoden fuer eine praktische Sprache basierend auf abh\"angigen Typen zu erproben.
Als Ergebniss wurde ein System mit einem neuartigem Terminierungskriterium, das mehrer bekannte Ideen kombinert, implementiert.
\end{abstract}
\newpage

\renewcommand{\abstractname}{Abstract}
\begin{abstract}
Dependent type theories have been used at the core of many theorem provers.
More recently, there are efforts to extend their use to functional programming languages.
Dependent types allow programming and reasoning about programs in one common framework.

The well known concept of pattern matching has been proposed for defining recursive functions in such systems.
While user-friendly and powerful, it enables the user to define non-terminating functions, i.e functions that don't compute a value in finite time. Such definitions cannot be allowed in a dependently typed system. 

It is known that the halteproblem is, in general, undecidable. Thus, no perfect method for checking termination will ever exist. To be on the safe side, there have to be definitions that are valid but will not be accepted.
Multiple methods have been proposed to broaden the range of allowed definitions.

The goal of this thesis was to investigate their feasibilityy for a practical language based on dependent types.
As a result, a system with a unique termination criterion that combines several ideas was implemented.
\end{abstract}
\tableofcontents
\input{intro}
\input{prelim}
\input{main}
\input{concl}
\input{appendix}
\input{bibl}

\end{document}