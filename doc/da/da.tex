\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm, amssymb}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{pxfonts}
\usepackage[german,english]{babel} 

\pagestyle{headings}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}

\newenvironment{bsp}
{\begin{list}{}{
\setlength{\leftmargin}{0cm}
\setlength{\rightmargin}{0cm}
}\item}{
\end {list}
}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\newcommand{\vex}[1]{\overrightarrow{#1}} 
\newcommand{\ves}[1]{{#1}^{\ast}} 

\newcommand{\vsp}{\:\vert\:}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\s}{\mathsf{s}\,}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\EPi}[2]{( #1 : #2 ) \rightarrow} 
\newcommand{\data}{\mathrm{data}\:}
\newcommand{\sized}{\mathrm{sized}\:}
\newcommand{\fun}{\mathrm{fun}\:}
\newcommand{\codata}{\mathrm{codata}\:}
\newcommand{\cofun}{\mathrm{cofun}\:}
\newcommand{\clet}{\mathrm{let}\:}
\newcommand{\ELet}[3]{\mathrm{let}\: #1 : #2 = #3 \: \mathrm{in}\:} 
\newcommand{\mutual}{\mathrm{mutual}\:}
\newcommand{\lam}[1]{\lambda\: #1 .\:}

\newcommand{\inacc}[1]{\underline{#1}}

\newcommand{\id}{\mathsf{id}\:}
\newcommand{\Nat}{\mathsf{Nat}\:}
\newcommand{\zero}{\mathsf{zero}\:}
\newcommand{\suc}{\mathsf{succ}\:}
\newcommand{\add}{\mathsf{add}\:}
\newcommand{\addt}{\mathsf{add_2}\:}

\newcommand{\NatP}{\mathsf{NatPair}\:}
\newcommand{\np}{\mathsf{np}\:}
\newcommand{\addp}{\mathsf{add_p}\:}

\newcommand{\even}{\mathsf{even}\:}
\newcommand{\odd}{\mathsf{odd}\:}

\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\ttt}{\mathsf{tt}\:}
\newcommand{\fff}{\mathsf{ff}\:}

\newcommand{\List}{\mathsf{List}\:}
\newcommand{\nil}{\mathsf{nil}\:}
\newcommand{\cons}{\mathsf{cons}\:}

\newcommand{\Term}{\mathsf{Term}\:}
\newcommand{\abs}{\mathsf{abs}\:}
\newcommand{\funt}{\mathsf{Fun}\:}
\newcommand{\func}{\mathsf{fn}\:}
\newcommand{\omegad}{\mathsf{omega}\:}
\newcommand{\app}{\mathsf{app}\:}

\newcommand{\Tree}{\mathsf{Tree}\:}
\newcommand{\leaf}{\mathsf{leaf}\:}
\newcommand{\node}{\mathsf{node}\:}

\newcommand{\vVec}{\mathsf{Vec}\:}
\newcommand{\head}{\mathsf{head}\:}
\newcommand{\rev}{\mathsf{rev}\:}
\newcommand{\reva}{\mathsf{rev1}\:}
\newcommand{\revb}{\mathsf{rev2}\:}


\newcommand{\flatt}{\mathsf{flat}\:}

\newcommand{\Eq}{\mathsf{Eq}\:}
\newcommand{\refl}{\mathsf{refl}\:}

\newcommand{\prof}{\mathsf{proof}\:}
\newcommand{\tprof}{\mathsf{proof2}\:}
\newcommand{\eqsucc}{\mathsf{eqsucc}\:}

\newcommand{\Bad}{\mathsf{Bad}\:}
\newcommand{\bad}{\mathsf{bad}\:}
\newcommand{\ok}{\mathsf{ok}\:}

\newcommand{\ProdT}{\mathsf{Prod}\:}
\newcommand{\prd}{\mathsf{prod}\:}
\newcommand{\pra}{\mathsf{pr_1}\:}
\newcommand{\prb}{\mathsf{pr_2}\:}
\newcommand{\quicksort}{\mathsf{quicksort}\:}
\newcommand{\qsapp}{\mathsf{qsapp}\:}
\newcommand{\pivot}{\mathsf{split}\:}
\newcommand{\lleq}{\mathit{leq}\:}
\newcommand{\ite}{\mathsf{ite}\:}

\newcommand{\Ord}{\mathsf{Ord}\:}
\newcommand{\ozero}{\mathsf{ozero}\:}
\newcommand{\olim}{\mathsf{olim}\:}
\newcommand{\addOrd}{\mathsf{addOrd}\:}

\newcommand{\Stream}{\mathsf{Stream}\:}
\newcommand{\tail}{\mathsf{tail}\:}
\newcommand{\nth}{\mathsf{nth}\:}

\newcommand{\wkSNat}{\mathsf{weakSNat}\:}
\newcommand{\wkSNatb}{\mathsf{badSNat}\:}
\newcommand{\wkStream}{\mathsf{weakStream}\:}


\newcommand{\minus}{\mathsf{minus}\:}
\renewcommand{\div}{\mathsf{div}\:}

\newcommand{\SNat}{\mathsf{SNat}\:}
\newcommand{\Maybe}{\mathsf{Maybe}\:}
\newcommand{\nothing}{\mathsf{nothing}\:}
\newcommand{\just}{\mathsf{just}\:}
\newcommand{\shift}{\mathsf{shift}\:}
\newcommand{\shiftcase}{\mathsf{shift\_case}\:}
\newcommand{\inc}{\mathsf{inc}\:}
\newcommand{\lop}{\mathsf{loop}\:}
\newcommand{\lopcase}{\mathsf{loop\_case}\:}
\newcommand{\diverge}{\mathsf{diverge}\:}

\newcommand{\zeroes}{\mathsf{zeroes}\:}
\newcommand{\unp}{\mathsf{unp}\:}
\newcommand{\zipWith}{\mathsf{zipWith}\:}
\newcommand{\fibs}{\mathsf{fib'}\:}
\newcommand{\fib}{\mathsf{fib}\:}
\newcommand{\fibf}{\mathsf{fib4}\:}

\newcommand{\Empty}{\mathsf{Empty}\:}
\newcommand{\BadNat}{\mathsf{BadNat}\:}
\newcommand{\foo}{\mathsf{foo}\:}

\newcommand{\addWith}{\mathsf{addWith}\:}

\newcommand{\ispd}{\mathsf{ISP}\:}
\newcommand{\spd}{\mathsf{SP}\:}
\newcommand{\putd}{\mathsf{put}\:}
\newcommand{\getd}{\mathsf{get}\:}
\newcommand{\isp}{\mathsf{isp}\:}
\newcommand{\ieat}{\mathsf{ieat}\:}
\newcommand{\eat}{\mathsf{eat}\:}

\newcommand{\adder}{\mathsf{adder}\:}
\newcommand{\cadder}{\mathsf{cadder}\:}
\newcommand{\iadder}{\mathsf{iadder}\:}

\newcommand{\eqo}{\mathsf{eq_0}\:}
\newcommand{\zeroest}{\mathsf{zeroes_2}\:}
\newcommand{\beqd}{\mathsf{Beq}\:}
\newcommand{\beq}{\mathsf{beq}\:}
\newcommand{\eqt}{\mathsf{eq_1}\:}

\newcommand{\ra}{\rightarrow}

\newcommand{\spc}{\hspace*{3mm}}
\newcommand{\spcx}{\hspace*{10mm}}
\newcommand{\vs}{\vspace*{1mm}}

\newcommand{\mugda}{\textsf{Mugda }}

\newtheorem{definition}{Definition}

\begin{document}
\begin{titlepage}
\begin{center}


\vspace*{-2cm}

\selectlanguage{german} 
{\Huge INSTITUT F\"UR INFORMATIK\\[1mm]} % 
DER LUDWIG--MAXIMILIANS--UNIVERSIT\"AT M\"UNCHEN\\

\vspace*{1cm}

\includegraphics[width=0.45\textwidth]{siegel.pdf}

\vspace*{2cm}

{\LARGE \textbf{Diplomarbeit}}\\

\vspace{2.0cm}
{\LARGE \textbf{TERMINATION CHECKING FOR A}}\\
\vspace*{3mm}
{\LARGE \textbf{DEPENDENTLY TYPED LANGUAGE}}\\

\vspace{2cm}

\Large{Dezember 2007}

\vspace{1.5cm}

  \begin{Large}
  \begin{tabular}{rl}
      Autor: &Karl Mehltretter\\
      Aufgabensteller: & Prof. Dr. Martin Hofmann\\
      Betreuer: & Dr. Andreas Abel\\
  \end{tabular}
  \end{Large}
\end{center}
\
\end{titlepage} 

\input{legal}


\title{Termination Checking for a dependently typed language}
\author{Karl Mehltretter}
\date{today}
\renewcommand{\abstractname}{Inhalt}
\begin{abstract}
Abh\"angige Typen werden als Basis f\"ur viele interaktive Theorembeweiser eingesetzt und es gibt seit einiger Zeit Bem\"uhungen, sie f\"ur allgemeine funktionale Programmiersprachen zu verwenden.
Eine Sprache mit abh\"angigen Typen erlaubt es, in einem gemeinsamen Rahmen sowohl Programme zu schreiben als auch Beweise zu formalisieren.

Das aus der Programmierung bekannte \emph{pattern matching} wurde als Mittel zur Definition von
rekursiven Funktionen in diesen Systemen vorgeschlagen.
Zwar ist pattern matching intuitiv und ausdrucksstark, doch muss sicher\-gestellt werden, dass die so definierten Funktionen total sind.

Ein Aspekt einer totalen Funktion ist Terminierung: Jeder Auswertung der Funktion muss in endlicher Zeit m\"oglich sein.  Unendlich Objekte k\"onnen unterst\"utzt werden, indem jeweils nur Teile davon berechnet werden.
G\"ultige Definitionen f\"ur unendliche Objekte m\"ussen \emph{produktiv} sein.

Da das Halteproblem unentscheidbar ist, kann das Ziel nur sein, m\"o\-glichst viele Definition als terminierend zu erkennnen. Es gibt verschiedene Ans\"atze zum Uberpr\"ufen der Terminierung.
Oft k\"onnen Funktionen, deren rekursive Aufrufe einem Schema wie folgen,
 vom System zugelassen werden. Das \emph{size change principle} umfasst einige dieser Schemata. 

Ein weiterer Vorschlag ist der Einsatz von \emph{sized types}. Information \"uber die Gr\"o\ss e von Argumenten wird im Typsystem verfolgt, um diese f\"ur das Erkennen der Terminierung zu nutzen.   

Im Rahmen dieser Diplomarbeit wurde das System \mugda entwickelt und wird nachfolgend vorgestellt.
Es basiert auf Typtheorie nach Martin-L\"of und unterst\"utzt induktive und co-induktive Typen. Funktionen werden  durch pattern matching definiert.
Das Kriterium f\"ur Terminierung basiert auf dem \emph{size change principle}.
Au\ss erdem stelle die Sprache Elemente bereit, um dem Benutzer die Verwendung von \emph{sized types} zu erm\"oglichen.
\end{abstract}
\newpage

\selectlanguage{english} 
\renewcommand{\abstractname}{Abstract}
\begin{abstract}
Dependent types have been used at the core of many proof assistants, and more recently there haven been efforts to extend their use to functional programming languages. 
Dependent type theories allow programming and reasoning in one common framework.

The \emph{pattern matching} notation, known from traditional programming, has been proposed for defining recursive functions in such systems.
While pattern matching is intuitive and powerful, it has to be ensured that the defined functions are total. 

One aspect of totality is termination: each evaluation of a function must be able to be computed in finite time.
Infinite objects can be added to the language by computing only finite parts of them as necessary.
Valid definitions of infinite objects need to be \emph{productive}. 

As the Halteproblem is undecidable, the goal can only be to accept as many valid definitions as possible.
There are many approaches to ensure termination.
One is to allow the definition of functions where the recursive calls follow a certain scheme.
The \emph{size change principle} subsumes some of these schemes.

With the use of \emph{sized types}, information about the height of arguments is tracked in the type system and can be used to recognize more definitions as terminating.  

For this thesis, the system \mugda was developed and will subsequently be described. It is based on \emph{Martin-L\"of type theory} and supports inductive and co-inductive types. Functions are defined by pattern matching. Its termination criterion is based on the size-change principle. In  addition, the language provides elements to enable the use of sized types.

\end{abstract}
\tableofcontents
\input{intro}
\input{main}
\input{concl}
\input{appendix}
\input{bibl}

\end{document}