\documentclass[a4paper,11pt]{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{subfig}
\usepackage{proof}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}

\newenvironment{bsp}
{\begin{list}{}{
\setlength{\leftmargin}{0cm}
\setlength{\rightmargin}{0cm}
}
\item}{
\end {list}
}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\newcommand{\vsp}{\;\vert\;}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\s}{\mathsf{s}\;}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\EPi}[2]{( #1 : #2 ) \rightarrow} 
\newcommand{\data}{\mathrm{data}\;}
\newcommand{\fun}{\mathrm{fun}\;}
\newcommand{\codata}{\mathrm{codata}\;}
\newcommand{\cofun}{\mathrm{cofun}\;}
\newcommand{\norec}{\mathrm{norec}\;}
\newcommand{\const}{\mathrm{const}\;}
\newcommand{\mutual}{\mathrm{mutual}\;}
\newcommand{\lam}[1]{\lambda\; #1 .\;}

\newcommand{\inacc}[1]{\underline{#1}}

\newcommand{\id}{\mathsf{id}\;}
\newcommand{\Nat}{\mathsf{Nat}\;}
\newcommand{\zero}{\mathsf{zero}\;}
\newcommand{\suc}{\mathsf{succ}\;}
\newcommand{\add}{\mathsf{add}\;}

\newcommand{\Bool}{\mathsf{Bool}\;}
\newcommand{\ttt}{\mathsf{tt}\;}
\newcommand{\fff}{\mathsf{ff}\;}

\newcommand{\List}{\mathsf{List}\;}
\newcommand{\nil}{\mathsf{nil}\;}
\newcommand{\cons}{\mathsf{cons}\;}


\newcommand{\Tree}{\mathsf{Tree}\;}
\newcommand{\leaf}{\mathsf{leaf}\;}
\newcommand{\node}{\mathsf{node}\;}

\newcommand{\vVec}{\mathsf{Vec}\;}
\newcommand{\head}{\mathsf{head}\;}
\newcommand{\rev}{\mathsf{rev}\;}
\newcommand{\reva}{\mathsf{rev1}\;}
\newcommand{\revb}{\mathsf{rev2}\;}

\newcommand{\Eq}{\mathsf{Eq}\;}
\newcommand{\refl}{\mathsf{refl}\;}

\newcommand{\prof}{\mathsf{proof}\;}
\newcommand{\tprof}{\mathsf{proof2}\;}
\newcommand{\eqsucc}{\mathsf{eqsucc}\;}

\newcommand{\Bad}{\mathsf{Bad}\;}
\newcommand{\bad}{\mathsf{bad}\;}
\newcommand{\ok}{\mathsf{ok}\;}

\newcommand{\Ord}{\mathsf{Ord}\;}
\newcommand{\ozero}{\mathsf{ozero}\;}
\newcommand{\olim}{\mathsf{olim}\;}
\newcommand{\addOrd}{\mathsf{addOrd}\;}

\newcommand{\Stream}{\mathsf{Stream}\;}
\newcommand{\tail}{\mathsf{tail}\;}
\newcommand{\nth}{\mathsf{nth}\;}

\newcommand{\ones}{\mathsf{ones}\;}
\newcommand{\unp}{\mathsf{unp}\;}
\newcommand{\zipWith}{\mathsf{zipWith}\;}
\newcommand{\fib}{\mathsf{fib}\;}
\newcommand{\fibf}{\mathsf{fib4}\;}

\newcommand{\Empty}{\mathsf{Empty}\;}
\newcommand{\BadNat}{\mathsf{BadNat}\;}
\newcommand{\foo}{\mathsf{foo}\;}


\newcommand{\ra}{\rightarrow}

\newcommand{\spc}{\hspace*{3mm}}
\newcommand{\spcx}{\hspace*{10mm}}
\newcommand{\vs}{\vspace{2mm}}
\newtheorem{definition}{Definition}

\begin{document}
\begin{titlepage}
\begin{center}


\vspace*{-2cm}

{\Huge INSTITUT F\"UR INFORMATIK\\[1mm]} % 
DER LUDWIG--MAXIMILIANS--UNIVERSIT\"AT M\"UNCHEN\\

\vspace*{1cm}

\includegraphics[width=0.4\textwidth]{siegel.pdf}

\vspace*{2cm}

{\Large \textbf{Diplomarbeit}}\\

\vspace{2.0cm}
{\Huge \textbf{Termination Checking for a}}\\
\vspace*{3mm}
{\Huge \textbf{dependently typed language}}\\

\vspace{2cm}

\large{Dezember 2007}

\vspace{1.5cm}

  \begin{Large}
      Autor : Karl Mehltretter\\
      Aufgabensteller : Prof. Dr. Martin Hofmann\\
      Betreuer: Dr. Andreas Abel
  \end{Large}

\end{center}
\end{titlepage} 

\input{legal}

\title{Termination Checking for a dependently typed language}
\author{Karl Mehltretter}
\date{today}

\begin{abstract}
Dependent type theories have been used at the core of many theorem provers.
More recently, there are efforts to extend their use to functional programming languages.
Dependent types allow programming and reasoning about programs in one common framework.

The well known concept of pattern matching has been proposed for defining functions in such systems.
While user-friendly and powerful, it enables the user to define non-terminating functions, i.e functions that don't compute a value in finite time. Such ddefinitionscan not be allowed in a dependently typed system. 

It is known that the halteproblem is, in general, undecidable. Thus, no perfect method for checking termination will ever exist. To be on the safe side, there have to be definitions that are valid but will not be accepted.
Multiple methods have been proposed to broaden the range of allowed definitions.

The goal of this thesis was to investigate their feasibilityy for a practical language based on dependent types.
As a result, a system with a unique termination criterion that combines several ideas was implemented.
\end{abstract}
\tableofcontents
\input{intro}
\input{prelim}
\input{main}
\input{concl}
\input{appendix}
\input{bibl}

\end{document}