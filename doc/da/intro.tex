\chapter{Introduction}

\paragraph*{Dependent type theory}

Dependent types were introduced as a central piece to Martin-L\"of's type theory \cite{mart84}. With the proofs-as-programs paradigm, they are a fundamental part of proof assistants like Coq \cite{coq} , Lego \cite{pollack94theory} and Twelf \cite{pfenning99system}.
As programming languages receive more and more powerful type systems, there have been renews efforts to use dependent types in programming languages: Languages such as Cayenne \cite{augustsson98cayenne}, Agda \cite{norell:thesis} and Epigram \cite{epigram} strife to be seen more as practial programming languages rather than logical frameworks. 

\paragraph*{Inductive families}
Type theory\footnote{for a good introductory text, the reader is referred to \cite{NPS:proml}}
 is often called an open theory: new constants can be added to the system.
As a programming language, there is the need to define inductive types like lists and trees.
To be used for logical purposes, inductive predicates have to be defined. 
Inductive families \cite{dybjer94inductive} offer a powerful general formulation for defining inductive types.  
For programming, one example could be the family of types Mat that is \emph{indexed} by two natural numbers.
The type for matrix multiplication could then be given as 
\[ \mbox{mult} : \mbox{Mat} \; k \; m \times \mbox{Mat} \; m \; n \ra \mbox{Mat} \; k \; n \]
which is not possible with simple type systems.
\paragraph*{Pattern Matching}
In traditional type theory, elimination constants for each data type provide primitive recursion. 
It was suggested (\cite{coquand92pattern}) to allow definitions by pattern matching, a well-known from programming languages (\cite{DBLP:conf/fpca/Augustsson85}).
It allows for more readable and intuitive definitions, which is essential for type theory to be useful as a programming languages. 
We note that pattern matching is not a conservative extension, but with addition of the K Axiom the pattern matching definitions can be translated back to traditional type theory(\cite{hofmann95groupoid,GoguHMcBrCM2006}). 

\paragraph*{Termination}
Beside the problem of complete coverage of patterns, pattern matching equations allow unrestricted recursion, and equations that define non-termination computation have to be disallowed: 
\begin{itemize}
\item
As types depend on terms, computation is performed during dependent type checking.
Thus, for type checking to be decidable, we cannot allow non-terminating computation. 
\item
For algorithms, termination is part of the correctness.
\item
Proofs as programs need to be total functions to be correct.
\end{itemize}
To be more concrete, let us look at a simple recursive definition by pattern matching on a list in a functional language: 
\begin{verbatim}
length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + length xs 
\end{verbatim}
The only recursive call is \texttt{length xs}.
The argument \texttt{xs} is structurally smaller than the input argument on the left hand side \texttt{(x:xs)}.
We conclude, if the list data type is well founded (i.e there are only finite lists), then the program \texttt{length} is guaranteed to terminate.
We note that we looked only at the defining equations of the function. Its type declaration was irrelevant to us.
\paragraph*{Term-based termination}
When pattern matching for dependent types was introduced in  \cite{coquand-pattern},
the test outlined above was suggestes as the syntactic criterion for termination. 

But not all defined functions have that clear \emph{structural recursive} form.
In \cite{abel-altenkrich},a decision procedure for a simple typed language is given that also handles lexicographic orderings on arguments and mutual recursion.
\cite{jones} devised the \emph{size change principle} that subsumes this effort and also handles functions with permutated arguments. 
\paragraph*{Type-based termination}
All of the above methods are part of methods called \emph{term-based termination}, where termination is, at least conceptually,  asserted by a separate \emph{termination checker} component of the system. 
Type-based termination \footnote{for an introduction, see chapter one in \cite{abel-phd}} refers to methods where the type checker itself is in charge of checking termination. Termination is ensured by the typing rules. 

The \emph{sized types} approach is an instance of type-based termination:
Types are decorated with size annotations that denote an upper bound on the height of the objects inhabiting them. 
It is then checked that the size is getting smaller in recursive calls. 

In comparison with term-based termination, sized types are more robust to syntactical changes of the program and the type system is able to use the information that certain functions are \emph{size-preserving}.
Some effort \cite{barthe} has been made to automatically infer these size annoations, making the sizes transparent for the user. 
\paragraph{Co-inductive Types}
There arises the need for potentially infinite objects, for example to model a continuous stream of network packages.
Streams, infinite sequences of elements, are the prime example of a \emph{co-inductive} type. 
While streams could be emulated by a function mapping natural numbers to elements, it is more 
natural and general to support directly support co-inductive types.

While \emph{co-recursive definitions} that create or manipulate infinite objects are in a sense non-terminating. 
they have to be \emph{productive}. For productive definitons, looking at any finite portion of the object is possible.
As for termination, there are syntactic tests to guarantee productivity (\cite{coquand-infinite}), but here again sized types offer a worthwhile alternative.  

\paragraph*{Mugda}
Our work started with an investigation of how a sized type approach could be added to a system like Agda.
The current version of Agda supports inductive families and mutual recursive function declarations by pattern matching. 
The Agda termination checker is based on the syntactic criterion of \cite{abel-altenkirch}.

In the description above, sized types sound like a very different approach compared to term-based termination.
But, with inductive families and pattern matching, these approaches can be naturally combined.

As a result, the system \mugda\footnote{short for Munich Agda} was developed.
It is a basic minimal language supporting inductive families, pattern matching and coinductive definitions.
As a special feature, the language offers a \emph{size type} to form size annotations. 
As a preview, we sketch how termination and productivity checking of defintions is handled by \mugda:
\begin{itemize}
\item
a syntactic termination checker based on the size-change principle is employed.
\item
In addition, the size type can be used to create sized data types, enabling advantages of the 
sized type approach.
\item
productivity of coinductive definitons is also enabled by the size type.
\item
usage of the size type has to be controlled by the type checker.
\end{itemize}  
\section{Overview}
We introduce the syntax and semantics of our \mugda language in the second chapter,
 and also detail the type checking algorithms.

In chapter 3, a basic termination criterion for inductive function definitions based on the size-change principle is presented. Then we motivate and present an extension that increases its strength for definitions involving structured objects.

We show in the fourth chapter how the built-in size type can be used to define sized data types and introduce sub-typing based on sized types.
We show how size types help to allow more valid inductive definitions from the criterion of the previous chapter,
and, more importantly, how it allows to verify productivity for co-inductive objects.
Last but not least we present an admissibility criterion that controls the use of the size type to valid purposes.

In chapter 5, we give details on how the system described in the previous chapter was implemented in the programming language Haskell.
Finally in chapter 6, we take a look back and give an overview of ideas for extensions and future research.





