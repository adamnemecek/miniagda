\appendix
\chapter{Mugda implementation}
Mugda was implemented in the function language Haskell \cite{haskell}.
\section{Overview}
\begin{itemize}
\item
\texttt{Lexer.x} : the alex lexer file
\item
\texttt{Parser.y} : the happy parser file
\item
\texttt{Concrete.hs} : concrete syntax produced by the parser
\item
\texttt{ScopeChecker.hs} : turns concrete into abstract syntax
\item
\texttt{Abstract.hs} : produced by the scope checker
\item
\texttt{Values.hs} : values and evaluation, Signature 
\item
\texttt{TypeChecker.hs} : type-checking with admissibility checking
\item
\texttt{Termination.hs} : structural Termination checker
\item
\texttt{Completeness.hs} : size pattern completeness check
\item
\texttt{SPos.hs} : strict positivity checker
\texttt{Main.hs} : the main module
\item
\texttt{example} directory: example input files
\end{itemize}

\section{Usage}

\mugda as presented was translated fairly close to an ASCII syntax:
\begin{itemize}
\item
lists of constructors and clauses are grouped with brackets \texttt{\{},\texttt{\}} and separated with semicolon \texttt{;}
\item
$\EPi{x}{A}{B}$ is written \texttt{(x : A) -> B }
\item
$A \ra B$ is written \texttt{A -> B}
\item
$\ELet{x}{A}{e}{f}$ is written \texttt{let x : A = e in f}
\item
$ \lam{x}e$ is written \verb+\x -> e +
\item
$ \inacc{e}$ is written \texttt{.e} 
\item
$ \infty$ is written \texttt{\#} 
\item
$\s$ is written \texttt{\$}
\item
comments up to the end of a line are prefixed by \verb+--+
\item
multi-line comments are put between \verb+{-+ and \verb+-}+
\end{itemize}
a \texttt{let} declaration can be prefixed with \texttt{eval}. Then the value will be evaluated after type checking is done.
As an example showing almost all syntactical features, here is the Fibonacci stream example (\texttt{examples/fib.ma}) in text format:
\begin{verbatim}
data Nat : Set {
  zero : Nat;
  succ : Nat -> Nat 
}

fun add : Nat -> Nat -> Nat {
  add zero = \y -> y;
  add (succ x) = \y -> succ (add x y)
}

sized codata Stream : Size -> Set {
  cons : (i : Size) -> Nat -> Stream i -> Stream ($ i)
}
 
fun tail : Stream # -> Stream # {
  tail (cons .# x xs) = xs
}

fun head : Stream # -> Nat {
  head (cons .# x xs) = x
}

fun nth : Nat -> Stream # -> Nat {
  nth zero xs = head xs;
  nth (succ x) xs = nth x (tail xs) 
}

let 1 : Nat = (succ zero)

cofun fib' : (x : Nat ) -> (y : Nat ) -> (i : Size ) -> Stream i {
  fib' x y ($ i) = cons i x (fib' y (add x y) i)
} 

-- fib = 1, 1, 2, 3, 5 , 8 ...
let fib : Stream # = (fib' 1 1 #)

let 4 : Nat = (succ (succ (succ 1)))

-- fib(4) = 5 
eval let fib4 : Nat = nth 4 fib 
\end{verbatim}
Running \texttt{Main examples/fib.ma} yields the console output:
\begin{verbatim}
***** Mugda v1.0 *****
--- scope checking ---
--- type checking ---
--- evaluating ---
fib4 evaluates to (succ (succ (succ (succ (succ zero)))))
\end{verbatim}

\section{Parsing}
The alex \cite{alex} and happy \cite{happy} tools where used for generating lexer and parser.
Monad transformers (\cite{Grabmueller2006MonadTransformers}) are used to keep the signature in a state monad,
to provide I/O and error tracing.

\section{Scope checking}
One part that was not really outlined in the main part is scope checking.
It is first step after parsing.
During parsing, identifiers are left not yet classified as variables, function symbols etc.
The syntax after parsing is called \emph{concrete syntax}.
The scope checker handles uniqueness of names and classifies identifiers, producing \emph{abstract syntax}.
Some simple syntactic tests like the linearity of patterns is also enforced during scope checking.
All used identifiers can be categorized as referring to a constructor, a variable or a defined data type or
function. After scope checking, it is guaranteed that looking up in signature or environments is guaranteed to succeed.



