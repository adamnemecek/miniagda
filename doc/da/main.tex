\chapter{Basic Mugda}

% Inference rules
\newcommand{\rulename}[1]{\ensuremath{\mbox{\sc#1}}}
\newcommand{\ru}{\dfrac}
\newcommand{\rux}[3]{\ru{#1}{#2}\ #3}
\newcommand{\nru}[3]{#1\ \ru{#2}{#3}}
\newcommand{\nrux}[4]{#1\ \ru{#2}{#3}\ #4}
\newcommand{\dstack}[2]{\begin{array}[b]{c}#1\\#2\end{array}}
\newcommand{\xstack}[3]{\begin{array}[b]{c}#1\\#2\\#3\end{array}}
\newcommand{\ndru}[4]{#1\ \ru{\dstack{#2}{#3}}{#4}}
\newcommand{\nxru}[5]{#1\ \ru{\xstack{#2}{#3}{#4}}{#5}}
\newcommand{\ndrux}[5]{#1\ \ru{\dstack{#2}{#3}}{#4}\ #5}


% rule names
\newcommand{\infvar}{\rulename{inf-var}}
\newcommand{\infset}{\rulename{inf-set}}
\newcommand{\infsize}{\rulename{inf-size}}
\newcommand{\infinfty}{\rulename{inf-infty}}
\newcommand{\infappa}{\rulename{inf-app-i}}
\newcommand{\infappb}{\rulename{inf-app-ii}}
\newcommand{\infcon}{\rulename{inf-con}}
\newcommand{\infdef}{\rulename{inf-fun}}
\newcommand{\inflet}{\rulename{inf-let}}
\newcommand{\infdata}{\rulename{inf-data}}

\newcommand{\chklet}{\rulename{chk-let}}
\newcommand{\chklam}{\rulename{chk-lam}}
\newcommand{\chkpi}{\rulename{chk-pi}}
\newcommand{\chksucc}{\rulename{chk-succ}}
\newcommand{\chkinf}{\rulename{chk-inf}}

\newcommand{\eqforce}{\rulename{eq-force}}

\newcommand{\eqsuc}{\rulename{eq-succ}}
\newcommand{\eqapp}{\rulename{eq-app}}
\newcommand{\eqpi}{\rulename{eq-pi}}
\newcommand{\eqlam}{\rulename{eq-lam}}
\newcommand{\eqatom}{\rulename{eq-atom}}

\newcommand{\chkpvar}{\rulename{chkp-var}}
\newcommand{\chkpcon}{\rulename{chkp-con}}
\newcommand{\chkpsucc}{\rulename{chkp-succ}}
\newcommand{\chkpinacc}{\rulename{chkp-inacc}}

\newcommand{\unifyl}{\rulename{inst-flex-l}}
\newcommand{\unifyr}{\rulename{inst-flex-r}}
\newcommand{\unifyc}{\rulename{inst-con}}
\newcommand{\unifyd}{\rulename{inst-data}}
\newcommand{\unifye}{\rulename{inst-eq}}
\newcommand{\unifys}{\rulename{inst-succ}}
\newcommand{\unifyi}{\rulename{inst-infty}}

\newcommand{\leqforce}{\rulename{leq-force}}

\newcommand{\leqsuc}{\rulename{leq-succ}}
\newcommand{\leqappco}{\rulename{leq-co}}
\newcommand{\leqappind}{\rulename{leq-ind}}
\newcommand{\leqappd}{\rulename{leq-data}}
\newcommand{\leqapp}{\rulename{leq-app}}
\newcommand{\leqpi}{\rulename{leq-pi}}
\newcommand{\leqlam}{\rulename{leq-lam}}
\newcommand{\leqatom}{\rulename{leq-atom}}

\newcommand{\sleqinfty}{\rulename{sleq-infty}}

\newcommand{\sleqsucci}{\rulename{sleq-succ-i}}
\newcommand{\sleqsuccii}{\rulename{sleq-succ-ii}}
\newcommand{\sleqgen}{\rulename{sleq-gen}}

\newcommand{\dd}{\mathsf{l}}
\newcommand{\DD}{\mathsf{D}}
\newcommand{\cc}{\mathsf{c}}
\newcommand{\ff}{\mathsf{f}}

\newcommand{\cDD}{\mathbb{D}}
\newcommand{\cdd}{\mathbb{L}}
\newcommand{\ccc}{\mathbb{C}}
\newcommand{\cff}{\mathbb{F}}
\newcommand{\cV}{\mathbb{V}}

\newcommand{\cS}{\mathbb{S}}
\newcommand{\cN}{\mathbb{N}}
\newcommand{\cB}{\mathbb{B}}
\newcommand{\cI}{\mathbb{I}}
\newcommand{\cF}{\mathbb{F}}
\newcommand{\nF}{\mathbf{N}}
\newcommand{\lF}{\mathbf{L}}
\newcommand{\rF}{\mathbf{R}}

\newcommand{\sz}{\mathbf{sz}}
\newcommand{\ns}{\mathbf{nosz}}
\newcommand{\co}{\mathbf{co}}
\newcommand{\ind}{\mathbf{ind}}

\newcommand{\Expr}{\mathrm{Expr}}
\newcommand{\Val}{\mathrm{Val}}
\newcommand{\AVal}{\mathrm{AVal}}
\newcommand{\vlam}{\mathrm{Lam}}
\newcommand{\vpi}{\mathrm{Pi}}
\newcommand{\cl}[2]{#1^{#2}}
\newcommand{\clp}[2]{\cl{(#1)}{#2}}
\newcommand{\Env}{\mathrm{Env}}
\newcommand{\wh}{\searrow}
\newcommand{\ap}{\mathrm{app}}
\newcommand{\apf}{\mathrm{app_{fun}}}
\newcommand{\sinfty}{\mathrm{s_{\infty}}}
\newcommand{\lkup}{\mathrm{lkup}}
\newcommand{\ins}[3]{#1,#2=#3}
\newcommand{\forc}{\mathrm{force}}
\newcommand{\matchcls}{\mathrm{match_{cls}}}
\newcommand{\matchcl}{\mathrm{match_{cl}}}
\newcommand{\match}{\mathrm{match}}
\newcommand{\matchf}{\mathrm{match_f}}
\newcommand{\matchList}{\mathrm{match_{list}}}
\newcommand{\matchInfty}{\mathrm{match_{\infty}}}
\newcommand{\stuck}{\:\Uparrow}
\newcommand{\Clause}{\mathrm{Clause}}
\newcommand{\Decl}{\mathrm{Decl}}
\newcommand{\Pat}{\mathrm{Pat}}

\newcommand{\Sig}{\mathrm{\Sigma}}


In the following sections, the syntax, semantics and type checking algorithms for \mugda will be described.
The starting point for this chapter was the simple dependent type checking algorithm that is given in \cite{coquand96algorithm}.

\noindent First some basic definitions:
\subsubsection{Natural numbers}
$ \cN = \{ 0 , 1 , ... \} $ is the set of natural numbers.
\subsubsection{Booleans}
$ \cB = \{ \top, \bot \} $ is the set of Boolean values.
\subsubsection{Sequence}
For some set $B$, $\ves{B}$ is the set of finite sequences over $B$.
The empty sequence is written as $\diamond$.
Sequences are written as $\vec{b}$ or $(b_1, \ldots b_n)$.
The length of a sequence is defined as $|(b_1,\ldots, b_n|)| := n $. 
\section{Syntax of Mugda}

\subsubsection{Identifier}
First we assume the following disjoint sets of identifiers.
\[
\begin{array}{ll}
\ccc \ni \cc & \mbox{for constructors}\\
\cDD \ni \DD & \mbox{for data types}\\
\cff \ni \ff & \mbox{for functions}\\
\cdd \ni \dd & \mbox{for global lets}\\
\cV \ni x,y,i & \mbox{for variables}
\end{array}
\]

\subsubsection{Expressions}
\[
\begin{array}{lrll}
\Expr \ni e,A,B & ::= & \lam{x}{e} & \mbox{abstraction}\\
& \mid & \EPi{x}{A}{B} & \mbox{dependent function type}\\
& \mid & e \: \vec{e} & \mbox{application}\\
& \mid & \ELet{x}{e_1}{A_1}{e_2} & \mbox{local let}\\ 
& \mid & \Set & \mbox{universe of small types}\\
& \mid & x & \mbox{variable}\\
& \mid & \cc & \mbox{constructor name}\\
& \mid & \DD & \mbox{data type name}\\
& \mid & \ff & \mbox{function name}\\
& \mid & \dd & \mbox{let name}
\end{array}
\]

\subsubsection{Patterns}
\[
\begin{array}{lrll}
\Pat \ni p & ::= & x & \mbox{variable pattern}\\
& \mid & \cc \: \vec{p} & \mbox{constructor pattern}\\
& \mid & \s p & \mbox{size successor pattern}\\
& \mid & \inacc{e} & \mbox{inaccessible pattern}\\
\end{array}
\]

\subsubsection{Constructor definitions}
\[
\begin{array}{lrll}
\gamma &  ::= & \cc \: : \: A & 
\end{array}
\]

\subsubsection{Clause definitions}
\[
\begin{array}{lrll}
\Clause \ni \kappa & ::= & \ff \: \vec{p} = e & 
\end{array}
\]

\subsubsection{Telescopes}
\[
\begin{array}{lrll}
\tau & ::= & \diamond & \mbox{empty telescope}\\
& \mid & ( x : t ) \: \tau & \mbox{parameter}\\
& \mid & ( + \: x : t ) \: \tau & \mbox{strictly positive parameter}
\end{array}
\]

Note that in a telescope, which is basically a sequence of type bindings, the types of later declared parameters can depend on earlier parameters. The $+$ annotation will be explained in the section on \emph{type checking}. 

\subsubsection{Declarations}
\[
\begin{array}{lrll}
\Decl \ni \delta & ::= & \data \DD \tau : A \vec{\gamma} & \mbox{inductive data type}\\ 
& \mid & \codata \DD \tau : A \vec{\gamma} & \mbox{co-inductive data type} \\
& \mid & \fun \ff : A \: \vec{\kappa} & \mbox{recursive function}\\
& \mid & \cofun \ff : A \: \vec{\kappa} & \mbox{co-recursive function}\\ 
& \mid & \clet \dd : A \: = e & \mbox{let declaration}\\
& \mid & \mutual \vec{\delta} & \mbox{mutual declaration}
\end{array}
\]



\subsubsection{Syntactic sugar}
$A \ra B$ is written for $\EPi{x}{A}{B}$ where $x$ is some variable not occurring in $B$.
For a telescope $\tau = (x_1 : A_1) \ldots (x_n : A_n)$ (ignoring the $+$ annotations) we write
$\tau \ra B$ for the expression  $\EPi{x_1}{A_1}{\ldots \ra \EPi{x_n}{A_n}{B}}$.
Accordingly, $\Gamma \ra B$ is an expression of the form $\EPi{x_1}{A_1}{\ldots \ra \EPi{x_n}{A_n}{B}}$.

A Mugda program $\vec{\delta}$ is a list of declarations.
For $\mutual$ declarations, we allow either multiple $\fun$ or multiple $\cofun$ declarations.
In the following, a single function declaration is simply treated as a special case of a mutual declaration.
Each declaration adds newly defined constructs to the signature $\Sig$, which is empty at the beginning.

\section{Semantics of Mugda expressions}
Computation is already needed during type checking for dependent types.
Thus, we need a semantic to be used during type checking.
The main ideas of the type checking algorithm of \cite{coquand96algorithm} are based on the idea of closures and generic values.
Closures, already introduced for computer science in \cite{Landin63}, are used for explicit substitution.
We simultaneously define values and environments:

\subsubsection{Values}
\[
\begin{array}{lrll}
\Val \ni v & ::= & v \: \vec{v} & \mbox{application}\\
& \mid & \vlam \: x \: \cl{e}{\rho} & \mbox{abstraction}\\
& \mid & \vpi \: x \: v \: \cl{e}{\rho} & \mbox{dependent function space}\\
& \mid & a & \mbox{atomic value}\\
\vs\\
\AVal \ni a & ::= & k & \mbox{generic value}\\
& \mid & \Set & \mbox{universe of small types} \\
& \mid & \cc & \mbox{constructor name}\\
& \mid & \ff & \mbox{function name}\\
& \mid & \DD & \mbox{data name}\\
\end{array}
\]
A generic value $k \in \cN$ represents the computed value of a variable during type checking.

\subsubsection{Environments}
\[
\begin{array}{lrll}
\Env \ni \rho & ::= & \diamond & \mbox{empty environment}\\
& \mid & \rho,x = v & \mbox{extended with binding}\\
\end{array}
\]

Values can be seen as partially evaluated expressions.
They are only partially evaluated because they may contain closures.
A closure $\cl{e}{\rho}$ is a pair of an expression $e$ and an environment $\rho$.
The environment provides bindings of the free variables in $e$.
\subsubsection{Signature}
The signature carries information about all user-defined constants.
It is defined as a overloaded function:
\begin{itemize}
\item
$ \Sig : \cff \ra \times \Val \times \ves{\Clause} \times \cB $\\
recording for a function symbol the type, the clauses and whether the clauses have been type-checked yet.
\item
$ \Sig : \cdd \ra \Expr \times \Val $ \\
recording for a global let constant the expression and its type. 
\item
$ \Sig : \ccc \ra \Val $
recording for a constructor its type.
\item
$ \Sig : \cdd \ra \Val \times \cN $\\
recording for a data type its type and the number of parameters.
\end{itemize}

Next is the evaluation of a closure $\cl{e}{\rho}$ to a value. 
A closed expression can be evaluated in an empty environment.
We simultaneously define evaluation as a function $\wh$ along with other functions.    
Some of these functions are partial because only type-correct expressions should be evaluated.
A fixed signature $\Sig$ is assumed.

\subsubsection{Evaluation}

\[
\begin{array}{ll}
\multicolumn{2}{l}{\wh \: : \Expr \times \Env \ra \Val}\\
\wh \clp{\lam{x}{e}}{\rho} & = \vlam \: x \: \cl{e}{\rho} \\
\wh \clp{\EPi{x}{A}{B}}{\rho} &= \vpi \: x \: v_A \: \cl{B}{\rho} \mbox{ where } v_A = \wh \cl{A}{\rho} \\
\wh \clp{\ELet{x}{A}{e_1}{e_2}}{\rho} &= \wh \cl{e_2}{\ins{\rho}{x}{v_1}} \mbox { where } v_1 = \wh \cl{e_1}{\rho} \\
\wh \clp{e \: e_1 \ldots e_n}{\rho} &= \ap \: v \: v_1 \ldots v_n \mbox{ where } v = \wh \cl{e}{\rho} , v_i = \wh \cl{e_i}{\rho}\\
\wh \cl{\Set}{\rho} & = \Set \\ 
\wh \cl{\cc}{\rho} & = \cc  \\
\wh \cl{\ff}{\rho} & = \ff \\
\wh \cl{\dd}{\rho} & = \wh \cl{e}{\diamond} \mbox{ where } \: \Sig \: \dd = (e,v_t)\\
\wh \cl{x}{\rho} & = \lkup \: \rho \: x \\
\end{array}
\]
The closure $c$  in $\vlam \: x \: \cl{e}{\rho}$
and $\vpi \: x \: v_a \: \cl{b}{\rho}$ do not have a binding for $x$.
The missing binding has to be provided before the closure can be evaluated.
This might be a concrete value (for example during $\beta$-reduction) or a
fresh generic value $k$ during type checking.

\subsubsection{Environment look-up}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\lkup : \Env \times \cV \ra \Val }\\
\lkup \: (\ins{\rho}{x}{v}) \: x & = v \\
\lkup \: (\ins{\rho}{y}{v}) \: x & = \lkup \: \rho \: x \mbox{ if } y \neq x  
\end{array}
\]

\subsubsection{Application}
does $\beta$-reduction and inductive function application. 
\[
\begin{array}{ll}
\multicolumn{2}{l}{\ap : \Val \times \ves{\Val} \ra \Val}\\
\ap \: u \: \diamond & = u \\
\ap \: (u \: \vec{c_1}) \: \vec{c_2} & = \ap \: u \: (\vec{c_1}\:\vec{c_2})\\
\ap \: (\vlam \: x \: \cl{e}{\rho}) \: (v \: \vec{v}) & = \ap \: v \: \vec{v} \mbox{ where } v = \wh \cl{e}{\ins{\rho}{x}{v}} \\ 
\ap \: \ff \: \vec{v} & = \apf \: \ff \: \vec{v} \mbox{ if } \ff \mbox{ is a } \fun \\ 
\ap \: v \: \vec{v} & = v \: \vec{v} \mbox{ otherwise } \\
\end{array}
\]
In the following, as pattern matching can fail, $\stuck$ is used to symbolize this. 
\subsubsection{Inductive function application}
We always reduce application of an inductive function if possible:\[
\begin{array}{ll}
\multicolumn{2}{l}{\apf : \cV \times \ves{\Val} \ra \Val}\\
\apf \: \ff \: \vec{v} & = v \mbox{ if } \Sig \: \ff = (\vec{\gamma},\top) \mbox { and } \matchcls \: \vec{\gamma} \: \vec{v} = v \neq \stuck \\ 
\apf \: \ff \: \vec{v} & = \ff \: \vec{v} \mbox { otherwise } 
\end{array}
\]


\subsubsection{Co-recursive unrolling}
An application of a co-recursive definition is lazily unrolled when needed: 
$\forc$ tries to unroll a co-recursive definition until a constructor appears:
\[
\begin{array}{ll}
\multicolumn{2}{l}{\forc : \Val \ra \Val }\\
\forc \: \ff & = \forc \; (\ff \diamond) \\
\forc \: (\ff \: \vec{v}) & = \forc \; v \mbox{ where } v = \matchcls \: \vec{\gamma} \: \vec{v} \neq \stuck \:\\
& \spcx \mbox{ if } \Sig \: \ff = (\vec{\gamma},\top) \mbox { and } \ff \mbox { is a } \cofun\\ 
\forc \: v & = \stuck \mbox{ otherwise}
\end{array}
\]


\subsubsection{Pattern matching}
Pattern matching returns an environment that binds the variables in the patterns to values.
When matching against a co-inductive constructor, the value is forced.
\[
\begin{array}{ll}
\multicolumn{2}{l}{\match : \Env \times \Pat \times \Val \ra \Env}\\
\match \: \rho \: (\cc \: \vec{p}) \: v & = \matchf \: \rho \: p \: v' \spc \mbox{if  } \cc  \mbox{ is a co-inductive constructor}\\
& \spcx \spcx \spcx \mbox{and } v' = \forc \: v \neq \stuck \\
\match \: \rho \: p \: v & = \matchf \: \rho \: p \: v \mbox{ otherwise}
\vs\\
\multicolumn{2}{l}{\matchf : \Env \times \Pat \times \Val \ra \Env}\\
\matchf \: \rho \: \inacc{e} \: v & = \rho \\
\matchf \: \rho \: x \: v & = \ins{\rho}{x}{v} \\
\matchf \: \rho \: (\cc \: \diamond) \: \cc & = \rho \\
\matchf \: \rho \: (\cc \: \vec{p}) (\cc \: \vec{v}) & = \matchList \: \rho \: \vec{p} \: \vec{v} \\
\matchf \: \rho \: p \: v & = \stuck \mbox{ otherwise}
\vs\\
\multicolumn{2}{l}{\matchList : \Env \times \ves{\Pat} \times \ves{\Val} \ra \Env }\\
\matchList \: \rho \: \diamond \: \diamond & = \rho \\
\matchList \: \rho \: (p \: \vec{p}) \: (v \: \vec{v}) & = \matchList \: \rho_2 \: \vec{p} \: \vec{v} \mbox{ where } \rho_2 \: = \match \rho \: p \: v \neq \stuck \\
\matchList \: \rho \: p \: v & = \stuck \mbox { otherwise } \\
\end{array}
\]

\subsubsection{Clause matching}
For a single clause, if all patterns of a clause match against the arguments, then the right hand side can be evaluated: 
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchcl : \Env \times \ves{\Pat} \times \Expr \times \ves{\Val} \ra \Val}\\
\matchcl \: \rho \: \diamond \: e \: \vec{v} & = \ap \: v \: \vec{v} \mbox{ where } v = \wh e \: \rho \\
\matchcl \: \rho \: (p \: \vec{p}) \: e \: (v \: \vec{v}) & = \matchcl \: \rho_2 \: \vec{p} \: \vec{v} \mbox{ if } \rho_2 = \match \: p v \neq \stuck \\  
\matchcl \: \rho \: \vec{p}\: e \: \vec{v} & = \stuck \mbox{ otherwise}\\  
\end{array}
\]

\subsubsection{Clauses matching} 
Now we define how a set of clauses matches against arguments. 
Each clause is tried until one is matched or there are no clauses left.It is assumed that clauses do not overlap, so the order in which the clauses are tried is not relevant. as at most one will match:
Note that matching for all clauses can fail even when the coverage is complete: First, there can be too few arguments.Furthermore, generic values (that are introduced during type checking) do not match against a constructor pattern. 
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchcls : \ves{\Clause} \times \ves{\Val} \ra \Val}\\
\matchcls \: \diamond \: \vec{v} & = \stuck \\
\matchcls \:  ((\vec{p} \: e)\:\vec{\gamma}) \: \vec{v} & = v \mbox{ if } v = \matchcl \: \diamond \: \vec{p} \: e \:  \vec{v} \neq \stuck \\
\matchcls \: ((\vec{p} \: e)\:\vec{\gamma}) \: \vec{v} & = \matchcls \: \vec{\gamma} \: \vec{v} \mbox{ otherwise}  
\end{array}
\]


\section{Examples}
\subsection{Identity function}
Without defining new data types, we still can define some useful non recursive functions.
One example is the polymorphic identity function. 
Mugda is monomorphic, so this is not really a polymorphic function, as you have to supply the
type as the first argument.
\begin{bsp}
$\clet id : \EPi{A}{\Set}{A \ra A} = \lam{a}\lam{x}x$   
\end{bsp}

\subsection{Booleans}
The Booleans are an example of a non-inductive enumeration type.
\begin{bsp}
$\data \Bool : \Set$  \\
$\spc \ttt : \Bool $\\
$\spc \fff : \Bool $
\end{bsp}

\subsection{Natural Numbers}
First we declare the type of natural numbers:
\begin{bsp}
$\data \Nat : \Set$ \\
$\spc \zero : \Nat $\\
$\spc \suc : \Nat \ra \Nat$
\end{bsp}
then the addition function can be defined by pattern matching:
\begin{bsp}
$\fun \add : \Nat \ra \Nat \ra \Nat$\\
$\spc \add x \: \zero = x $\\
$\spc \add x \: (\suc y) = \suc (\add x \: y)  $
\end{bsp}
\subsection{Lists}
Lists are an example of a parametrized data type:
\begin{bsp}
$\data \List ( + A : \Set ) : \Set $ \\
$ \spc \nil : \List A  $\\
$ \spc \cons : A \ra \List A \ra \List A $
\end{bsp}
\subsection{Finitely branching trees}
\label{tre}
The following introduces finitely branching trees where leafs contain elements of $A$ and nodes are contain elements of of $B$:
\begin{bsp}
$\data \Tree ( + A : \Set ) ( + B : \Set ) : \Set $ \\
$ \spc \leaf : A \ra \Tree A \: B $\\
$ \spc \node : B \ra \List (\Tree A \: B) \ra \Tree A \: B $
\end{bsp}

\subsection{Vectors}
Now things get more interesting. Vectors are an example of an inductive family of types.
They can be imagined as lists that store their length.
\begin{bsp}
$\data \vVec ( + A : \Set ) : \Nat \ra \Set $ \\
$\spc \nil : \vVec A \: \zero  $\\
$ \spc \cons : \EPi{n}{\Nat}{ A \ra \vVec A \: n \ra \vVec A \: (\suc n)} $
\end{bsp}
Now let's define the $\head$ function that returns the first element of an vector. This operation should only be allowed for a non-empty vector.
With dependent types, we can express this in the type signature
\begin{bsp}
$ \fun \head : ( A : \Set ) \ra ( n : \Nat ) \ra \vVec A \: (\suc n) \ra A $
\end{bsp}
Now on to the clause definition, we can explain the usage of inaccessible patterns here.
Pattern matching against the list is needed:
\begin{bsp}
$\head ? \: ? \: (\cons \: B \: m \: x \: xl) = x $
\end{bsp}
First, one should note that we pattern matching against $\nil$ is not needed, because it does not belong to
a type of the form $\Vec A (\suc n)$.
Now, what about the question marks above. 
One might be inclined to use non-linear patterns:
\begin{bsp}
$\head \: B \: m \: (\cons  B \: m \: x \: xl) = x $
\end{bsp}
But really you don't have to check at run-time that the values at the corresponding arguments match - it is guaranteed for a well-typed program.
So to really capture the notion that the first two arguments are automatically instantiated by pattern matching against the inductive family argument, the inaccessible pattern notation is used. The final definition is:
\begin{bsp}
$ \fun \head : ( A : \Set ) \ra ( n : \Nat ) \ra \vVec A \: (\suc n) \ra A $\\
$ \spc \head \inacc{B} \: \inacc{m} \: (\cons \: B \: m \: x \: xl) = x $
\end{bsp}
\subsection{Equality}
The following is called Martin-L\"of equality, another important example of an inductive family.
This equality relation is defined by a single constructor for reflexivity:
\begin{bsp}
$\data \Eq ( A : \Set ) : A \ra A \ra \Set $ \\
$\spc \refl : \EPi{a}{A}{\Eq A \: a \: a}$
\end{bsp}
As a simple example, we can now prove the mathematical statement $ . x  + 0 = x $:
\begin{bsp}
$ \clet \prof : \EPi{x}{\Nat}{\Eq \Nat (\add x \: \zero)\: x} $ \\ 
$ \spcx = \lam{y}\refl \Nat y$ 
\end{bsp}
Here one can see that proof checking is type checking.
Without having formally introduced type checking, we want to give some intuition how it is done.
This proofs passes the type checker because $\add x \: \zero$ reduces to $\zero$ and the type checker knows that $\zero$ is equal to itself.
Now if we want to prove $ \forall x \in \cN 0 +  x = x $, we need more effort.
The following does not pass the type checker:
\begin{bsp}
$ \clet \tprof : \EPi{x}{\Nat}{\Eq \Nat (\add \zero x)\: x} $ \\ 
$ \spcx \lam{y} \refl \Nat y$ 
\end{bsp}
The reason why is that the type checker can only see definitional equality.
Note that addition was defined by recursion on the second argument.
Technically, the generic value introduced for $y$ does neither match against the pattern $\zero$ in the first clause
nor against the pattern $\suc y$ in the second clause of $\add$, so $\add \zero x$ does not reduce to $x$ during type checking.
So what is needed is a recursive proof by manually doing case distinction on x:
\begin{bsp}
$\fun \eqsucc : \EPi{x}{\Nat}\EPi{y}{\Nat} \Eq \Nat x \: y \ra \Eq \Nat (\suc x) \: (\suc y)$ \\
$\spc \eqsucc \inacc{x} \: \inacc{x} \: (\refl \inacc{\Nat} \: x) = \refl \Nat (\suc x)$
\vs\\
$\fun \tprof : ( x : \Nat ) \ra \Eq \Nat (\add \zero x) x$\\
$\spc \tprof \zero = \refl \Nat \zero$\\
$\spc \tprof (\suc x) = \eqsucc (\add \zero x)\: x \: (\tprof x)$
\end{bsp}

Recursive proofs need to be total, i.e complete pattern coverage and termination, to be correct.

\subsection{Streams}
Next we introduce streams of natural numbers as an example of a co-inductive type.
Co-inductive types are not required to be well-founded, i.e their inhabitants do not need to have an finite height.
\begin{bsp}
$\codata \Stream : \Set $ \\
$\spc \cons : \Nat \ra \Stream \ra \Stream $
\end{bsp}
Note that because $\Stream$ has only one constructor, there are no finite $\Stream$ objects.
A stream of zeroes can be generated by:
\begin{bsp}
$\cofun \zeroes: \Stream $ \\
$\spc \zeroes = : \cons \zero \zeroes$
\end{bsp}

\begin{bsp}
$\fun \head : \Stream \ra \Nat$\\
$\spc \head \: (\cons \: x \: xs) = x$
\end{bsp}

As expected, $\wh\; {\cl{\head \zeroes}{\diamond}} = \zero $ because $\head$ triggers a $\forc$. Termination is guaranteed because $\zeroes$ is productive.

\section{Limitations}
In comparison to Agda, $\mugda$ is missing a lot of features.
Due to its use for interactively building proofs. Agda has meta-variables that represent parts of the proof that are still missing. 

Also, many arguments to a function can be easily inferred by the type checker.
The user can mark these arguments as \emph{implicit}. The type checker will automatically infer them,, which is really beneficial for the user.
To keep Mugda simple, these features were not implemented.

Furthermore, we are limited to one universe $\Set$.
One could easily have $\Set$ as the type of all types ($\Set : \Set$), but then the system is prone to paradoxes and inconsistencies (\cite{coquand86analysis,coquand92pattern}).
The solution is to apply universe stratification and move to a predicative hierarchy of universes $ \Set = \Set_0 , \Set_1 , \Set_2 $ and so on. 
\section{Type Checking}

\renewcommand\Check[5]{#1;#2;#3\vdash#4\leftleftarrows#5}
\newcommand\IsType[4]{#1;#2;#3\vdash#4\:\mathbf{Type}}
\newcommand\DataType[5]{#1;#2;#3;#4\vdash#5\:\mathbf{Data Type}}
\newcommand\ConType[5]{#1;#2;#3;#4\vdash#5\:\mathbf{Con Type}}
\newcommand\Infer[5]{#1;#2;#3\vdash#4\rightrightarrows#5}
\newcommand\EqVal[4]{#1;#2\vdash#3\Leftrightarrow#4}
\newcommand\FeqVal[4]{#1;#2\vdash#3{\:\leftrightarrow\:}#4}
\newcommand\DeqVal[2]{\vdash#1\leftrightarrow#2}
\newcommand\LeqVal[4]{#1;#2;\vdash#3\leq#4}
\newcommand\FleqVal[4]{#1;#2\vdash#3{\:\ll\:}#4}
\newcommand\DLeqVal[2]{\vdash#1\leq#2}
\newcommand\SzLeq[2]{\vdash#1\sqsubseteq#2}

\subsection{Bidirectional type checking} 
For dependent types, a practice called \emph{bidirectional type checking} is used.
This means that the type checker has two modes:
one for checking that an expression has a certain type and one for inferring the type of an expression.

\begin{description}
\item[check expression]:
\[\Check{k}{\rho_1}{\rho_2}{e}{v} \subseteq \cN \times \Env \times \Env \times \Expr \times \Val\]
\item[infer expression]:
\[\Infer{k}{\rho_1}{\rho_2}{e}{v} : \cN \times \Env \times \Env \times \Expr \ra \Val\]
\item[is type]:
\[\IsType{k}{\rho_1}{\rho_2}{e} \subseteq \cN \times \Env \times \Env \times \Expr \]
\end{description}

The environment $\rho_1$ will be used to bind fresh generic values to variables, and $\rho_2$ will have the type corresponding to this variables. in checking mode, the type checker might have to infer the type of the expression and then verify that the inferred value is equal to the one to be checked against.
So one needs equality between two values.
We want to strengthen equality of co-inductive values by allowing the type checker to unroll ($\forc$) a co-recursive definition. We cannot allow unlimited unfolding, thus we keep track of unfolding and only allow one of the values to be unrolled.
We introduce the set $ \cF = \{\lF, \rF, \nF \} $ to keep track if we have unrolled the left or right value or not at all.
Thus we introduce simultaneously two judgments, the latter one operating on already unrolled values.
\[\EqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times \Val \times \Val \]
\[\FeqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times\Val \times \Val \]

\begin{figure}

\begin{gather*}
%% Let
\ndru{\chklet}
{
\IsType{k}{\rho_1}{\rho_2}{t_1}
\qquad
\Check{k}{\rho_1}{\rho_2}{e1}{\wh \cl{t_1}{\rho_1}}
}
{
\Check{k}{\ins{\rho_1}{x}{\wh \cl{e_1}{\rho_1}}}{\ins{\rho_2}{x}{\wh \cl{t_1}{\rho_1}}}{e_2}{v}
}
{\Check{k}{\rho_1}{\rho_2}{\ELet{x}{t_1}{e_1}{e_2}}{v}}
\\[2ex]
%Lam
\nru{\chklam}
{\Check{k+1}{\ins{\rho_1}{x}{k}}{\ins{\rho_2}{x}{v_a}}{e}{\wh \cl{t}{\ins{\rho}{x}{k}}}}
{\Check{k}{\rho_1}{\rho_2}{\lam{x}{e}}{\vpi \: x \: v_a \: \cl{t}{\rho}}}
%% Pi
\\[2ex]
\nru{\chkpi}
{\Check{k}{\rho_1}{\rho_2}{t_1}{\Set}
\qquad
\Check{k+1}{\ins{\rho_1}{x}{k}}{\ins{\rho_2}{x}{\cl{t_1}}{\rho_1}}{t_2}{\Set}
}
{\Check{k}{\rho_1}{\rho_2}{\EPi{x}{t_1}{t_2}}{\Set}}
\\[2ex]
%% Infer-mode
\nru{\chkinf}
{\Infer{k}{\rho_1}{\rho_2}{e}{v_2}
\qquad
{\EqVal{\nF}{k}{v_2}{v_1}}} 
{\Check{k}{\rho_1}{\rho_2}{e}{v_1}}
\end{gather*}
\caption{Checking expressions}
\end{figure}

\begin{figure}
\begin{gather*}
%% App-1
\nru{\infappa}
{\Infer{k}{\rho_1}{\rho_2}{e_1}{\vpi \: x \: v_a \: \cl{b}{\rho}}
\qquad \Check{k}{\rho_1}{\rho_2}
{e_2}{v_a}}
{\Infer{k}{\rho_1}{\rho_2}{e_1 \: e_2}{\wh \cl{b}{\ins{\rho}{x}{\cl{e_2}{\rho_1}}}}}
%% App-2
\\[2ex]
\nru{\infappb}
{\Infer{k}{\rho_1}{\rho_2}{(e_1 \: e_2)\:\vec{e}}{v}}
{\Infer{k}{\rho_1}{\rho_2}{e_1 \: (e_2 \: \vec{e})}{v}}
\qquad
%% Var
\nru{\infvar}{\lkup \: \rho_2 \: x \: v}{\Infer{k}{\rho_1}{\rho_2}{x}{v}}
\\[2ex]
%% Def	
\nru{\infdef}
{\Sig \: \ff \: = (v,\vec{\gamma}) }
{\Infer{k}{\rho_1}{\rho_2}{\ff}{v}}
\qquad
%% Con 
\nru{\infcon}
{\Sig \: \cc \: = v}
{\Infer{k}{\rho_1}{\rho_2}{\cc}{v}}
\\[2ex] 
%% Data
\nru{\infdata}
{\Sig \: \DD \: = (v,n)}
{\Infer{k}{\rho_1}{\rho_2}{\DD}{v}} 
%% Const
\qquad
\nru{\inflet}
{\Sig \: \dd \: = (e,v)}
{\Infer {k}{\rho_1}{\rho_2}{\dd}{v}}
\end{gather*}
\caption{Inferring type of expressions}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{\IsType{k}{\rho_1}{\rho_2}{t_1}
\qquad
\IsType{k+1}{\ins{\rho_1}{x}{k}}{\ins{\rho_2}{x}{\cl{t_1}{\rho}}}{t_2}}
{\IsType{k}{\rho_1}{\rho_2}{\EPi{x}{t_1}{t_2}}}
\\[2ex]
\nru{}{}{\IsType{k}{\rho_1}{\rho_2}{\Set}}
\qquad
\nru{}
{\Check{k}{\rho_1}{\rho_2}{t}{\Set}}
{\IsType{k}{\rho_1}{\rho_2}{t}}
\end{gather*}
\caption{Type judgment}
\end{figure}

\begin{figure}
\begin{gather*}
%% Force
\nxru{\leqforce}
{\FeqVal{\lF}{k}{\forc \; v_1}{v_2} \qquad \mbox{if } \forc \: v_1 \neq v_1 , \forc \: v_2 = v_2  , f \neq \rF
}
{\FeqVal{\rF}{k}{v_1}{\forc \; v_2} \qquad \mbox{if } \forc \: v_1 = v_1 , \forc \: v_2 \neq v_2 , f \neq \lF }
{\FeqVal{f}{k}{v_1}{v_2} \qquad \qquad \qquad \qquad \qquad \mbox{ otherwise}}
{\EqVal{f}{k}{v_1}{v_2}}
\\[2ex]
%% App
\nru{\eqapp}
{\EqVal{f}{k}{v}{w} \qquad
\EqVal{f}{k}{v_1}{w_1} \qquad \ldots \qquad \EqVal{f}{k}{v_n}{w_n}}
{\FeqVal{f}{k}{v \: v_1 \ldots v_n}{w \: w_1 \ldots w_n}}
%% Pi
\\[2ex]
\nru{\eqpi}
{\EqVal{f}{k}{a_1}{a_2}
\qquad
\EqVal{f}{k+1}{\wh \cl{b_1}{\ins{\rho_1}{x_1}{k}}}{\wh \cl{b_2}{\ins{\rho_2}{x_2}{k}}}}
{\FeqVal{f}{k}{\vpi \: x_1 \: a_1 \: \cl{b_1}{\rho_1}}{\vpi \: x_2 \: a_2 \: \cl{b_2}{\rho_2}}}
%% Lam
\\[2ex]
\nru{\eqlam}
{\EqVal{f}{k+1}{\wh \cl{b_1}{\ins{\rho_1}{x_1}{k}}}{\wh \cl{b_2}{\ins{\rho_2}{x_2}{k}}}}
{\FeqVal{f}{k}{\vlam \: x_1 \: \cl{b_1}{\rho_1}}{\vlam \: x_2 \: \cl{b_2}{\rho_2}}}
%% Atom
\qquad
\nru{\eqatom}
{}
{\FeqVal{f}{k}{a}{a}}
\end{gather*}
\caption{equality checking}
\end{figure}

After having defined the basic building blocks, now it has to be defined how individual declarations are checked.

\subsection{Checking let declarations}
Checking a let declaration is pretty straightforward.
The steps are:
\subsubsection{Type-checking} 

For the let declaration $ \delta = \clet \dd : A = e $, assuming a type checked signature $\Sigma$, if
\begin{enumerate}
\item
$\IsType{1}{\diamond}{\diamond}{A}$
\item
$ v_a := \wh \cl{A}{\diamond}$
\item
$\Check{1}{\diamond}{\diamond}{e}{v_a}$
\item
$\Sig := \Sig \cup \{\dd \mapsto (e,v_a)\}$
\end{enumerate}
succeeds then $\delta$ is type-correct and $\Sig$ is a type-checked signature.

\subsection{Checking data-type declarations}
We have to check that data type declarations follow the scheme of inductive families.
Actually, we here stay closer to how data type declarations are checked in the current version Agda.
It is a more liberal then the schemata given in the original paper \cite{dybjer94inductive}: The notion of strict positivity is a more lenient. In addition, \mugda supports co-inductive types with the $\codata$ construct.

\noindent A valid data type declarations first needs to have this syntactic form:
\begin{quote}
$\data \DD ( p_1 : P_1) \ldots ( p_n : P_n) : \Gamma \ra \Set $\\
$\spc \ldots$\\
$\spc \cc : \Delta \ra \DD p_1 \ldots p_n t_1 \ldots t_m$\\
$\spc \ldots$\\   
\end{quote}
\newcommand{\pos}{\mbox{pos}}
where each $(p_i : P_1) $ can be marked with a $+$ to denote strict positivity.
\subsubsection{Positive parameters}
For $\DD$, we define the set of positive parameter indices $\pos(\DD)$:

\[\pos(\DD) \subseteq \cN := \{ \: i \mid p_i \mbox{ is declared strictly positive} \}\]

The parameter types $P_i$ can be arbitrary types, while the types in $\Gamma$ and $\Delta$ need to be small types, i.e of type $\Set$. Also, the parameters $p_i$ have to be written down in the target of each constructor exactly as declared in the telescope.

We require that data-type declarations are strictly positive.
Otherwise there are inconsistencies (\cite{paulinmohring93inductive}), i.e non-terminating terms could be constructed.
Strict positivity roughly means that in the type of the arguments $\Delta$ of every constructor , every recursive argument $\DD$ is not allowed in the domain of a function type or as an a argument of an application.

An exception to this that is allowed in \mugda is that parameters that are for themselves strictly positive can be marked with a $+$ and will then preserve strict positivity. 
This allows the definition of the $\Tree$ type in section \ref{tre} to pass the strict positivity test. In that regard, \mugda 's data types are closer to the \emph{strictly positive families} described in \cite{alti:cats07}.
In the following, we describe the checking of $\data$ declarations, but $\codata$ are checked just the same.

\newcommand{\sposc}[3]{#1\vdash#2\mbox{ \textbf{sposc} }#3}
\newcommand{\spos}[3]{#1\vdash#2\mbox{ \textbf{spos} }#3}

\subsubsection{Type-checking data declaration}


To check that the data declaration
\[\begin{array}{l}
\data \DD \: \tau : A \\
\spcx \vec{\gamma}
\end{array}
\]
is valid, the following steps are performed: 
\begin{enumerate}
\item
$\DataType{1}{\diamond}{\diamond}{\vert\tau\vert}{ \tau \ra A}$
\item
$v_D := \wh \clp{\tau \ra A}{\diamond}$
\item
$\Sig := \Sig \cup \{\DD \mapsto v_D\}$
\item
for every constructor declaration $\cc : B  \in \vec{\gamma}$:
\begin{enumerate} 
\item
$\ConType{1}{\diamond}{\diamond}{n}{\tau \ra B}$
\item
$v_C := \wh \clp{\tau \ra B}{\diamond}$
\item
$\sposc{1}{v_C}{i}$ for every $i \in \pos(\DD) $ 
\item
$\sposc{1}{v_C}{\DD}$
\item
$\Sig := \Sig \cup \{\cc \mapsto v_C\}$
\end{enumerate}
\end{enumerate}

\newcommand{\nocc}[3]{#1\vdash#2\mbox{ \textbf{nocc} }#3}

\begin{figure}
\begin{gather*}
\nxru{}
{\mbox {if } k < n \mbox{ then } \IsType{k}{\rho_1}{\rho_2}{A}}
{\mbox {if } k \geq n \mbox { then } \Check{k}{\rho_1}{\rho_2}{A}{\Set}}
{\DataType{k+1}{\ins{\rho_1}{x}{k}}{\ins{\rho_2}{x}{\cl{A}{\rho}}}{n}{B}}
{\DataType{k}{\rho_1}{\rho_2}{p}{\EPi{x}{A}{B}}}
\\[2ex]
\nru{}
{}
{\DataType{k}{\rho_1}{\rho_2}{n}{\Set}}
\end{gather*}
\caption{Data type judgment}
\end{figure}

\begin{figure}
\begin{gather*}
\ndru{}
{\mbox {if } k \geq n \mbox { then } \Check{k}{\rho_1}{\rho_2}{A}{\Set}}
{\ConType{k+1}{\ins{\rho_1}{x}{k}}{\ins{\rho_2}{x}{\cl{A}{\rho}}}{\DD p_1 \ldots p_n}{B}}
{\ConType{k}{\rho_1}{\rho_2}{n}{\EPi{x}{A}{B}}}
\\[2ex]
\nru{}
{\IsType{k}{\rho_1}{\rho_2}{\DD p_1 \ldots p_n t_1 \ldots t_m}}
{\ConType{k}{\rho_1}{\rho_2}{n}{\DD p_1 \ldots p_n t_1 \ldots t_m}}
\end{gather*}
\caption{Constructor type judgment}
\end{figure}


\begin{figure}
\begin{gather*}
\nru{}
{\nocc{k}{a}{v_a} \qquad \nocc{k+1}{a}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\nocc{k}{a}{\vpi \: x \: v_a \: \cl{b}{\rho}}  }
\qquad
\nru{}
{\nocc{k+1}{a}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\nocc{k}{a}{\vlam \: x \: \cl{b}{\rho}}  }
\\[2ex]
\nru{}
{\nocc{k}{a}{v} \qquad \nocc{k}{a}{v_j} \mbox{ for all } j \in \{1 \ldots n \}}
{\nocc{k}{a}{v \: v_1 \ldots v_n}}
\qquad
\nru{}
{a \neq a'}
{\nocc{k}{a}{a'}}
\end{gather*}
\caption{Nonoccurence of atomic value a}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{ \nocc{a}{a}{v_a} \qquad \spos{k+1}{a}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\spos{a}{a}{\vpi \: x \: v_a \: \cl{b}{\rho}}  }
\qquad
\nru{}
{\spos{k+1}{a}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\spos{k}{a}{\vlam \: x \: \: \cl{b}{\rho}}  }
\\[2ex]
\nru{}
{\nocc{k}{a}{v_j} \mbox{ for all } j \in \{1 \ldots n \}} 
{\spos{k}{a}{a \: v_1 \ldots v_n}}
\\[2ex]
\ndru{}
{\nocc{k}{a}{v_j} \mbox{ for all } j \in \{ 1 \ldots m\} , j \notin \pos(\DD)}
{\spos{k}{a}{v_k} \mbox{ for all } k \in \pos(\DD) \qquad}
{\spos{k}{a}{\DD \: v_1 \ldots v_m}}
\\[2ex]
\nru{}
{\spos{k}{a}{v} \qquad \nocc{k}{a}{v_j} \mbox{ for all } j \in \{1 \ldots n \}}
{\spos{k}{a}{v \: v_1 \ldots v_n}}
\qquad
\nru{}
{}
{\spos{k}{a}{v}}
\end{gather*}
\caption{Strictly positive occurrence of atomic value a}
\end{figure}


\begin{figure}
\label{sposcf}
\begin{gather*}
\nru{}
{ \spos{k}{a}{v_a} \qquad \sposc{k+1}{a}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\sposc{k}{a}{\vpi \: x \: v_a \: \cl{b}{\rho}}  }
\nru{}
{}
{\sposc{k}{a}{v}}
\end{gather*}
\caption{strict positivity test for atomic value a in constructor arguments}
\end{figure}

The strict positivity test for a constructor is given in figure \ref{sposcf}.
The following declaration is rejected because of the non-positive occurrence of $\Bad$ in the argument of $\bad$.
\begin{bsp}
$\data \Bad : \Set $ \\
$\spc \ok : \Bad$\\
$\spc \bad : ((\Nat \ra \Bad) \ra \Bad) \ra \Bad  $
\end{bsp}

Also, the declaration 
\begin{bsp}
$\data \Bad : ( + A : \Set ) : \Set $\\
$\spc \ok : \Bad A$\\
$\spc \bad : (A \ra \Bad) \ra \Bad A$
\end{bsp}
is not valid because of the negative occurrence of $A$ in the argument of $\bad$.
\subsection{Checking function declarations}

\newcommand\checkcl[2]{#1\:\mathbf{checkcl}\:#2}
\newcommand\checkp[5]{(#1)\vdash#2\:\mathbf{Pat}\:#3\Rightarrow (#4),#5}
\newcommand\checkps[5]{(#1)\vdash#2\:\mathbf{Pats}\:#3\Rightarrow (#4),#5}
\newcommand\checkinacc[4]{(#1)\vdash#2\:\mathbf{checkinacc}\:#3 : #4}
\newcommand\unify[5]{#1,#2\vdash#3\:\mathbf{inst}\:#4\Rightarrow #5}
\newcommand\unifylist[5]{#1,#2\vdash#3\:\mathbf{inst_{list}}\:#4\Rightarrow #5}


\subsubsection{Overview}
We need to check each clause $\ff \vec{p} e$ of a function separately against the declared type.
So for each clause, we have to check the patterns $\vec{p}$ and then the right hand side $e$.
Checking the patterns $\vec{p}$ will yield an environment for the free variables in $e$.
We expect the patterns to be \emph{linear} in the pattern variables.

Because of the inaccessible patterns, checking $\vec{p}$ will need two phases.
In the first phase, we will skip checking of inaccessible patterns.
They will be represented by fresh \emph{flexible} generic values.
These flexible generic values will be \emph{instantiated} to concrete values when checking constructor patterns.
Then in thee second phase, it is verified that the expressions of the inaccessible patterns are equal to those instantiated in the first phase.
\newcommand{\subst}[2]{#1\{#2\}}
\newcommand{\substEnv}[2]{#1\{#2\}}
\newcommand{\compS}[2]{\mathrm{comp}\:#1\:#2}
\newcommand\ptv[2]{#1\Searrow#2}
\newcommand\ptvx{\mathrm{p2v}}
\newcommand\pstvs{\mathrm{p_{s}2v_{s}}}

Instantiating by successful unification will yield a substitution:
\subsubsection{Substitutions}
A substitution is a list $\sigma : \ves{(\cN \times \Val)} $ and denotes a partial mapping of generic values to values.
$\diamond$ is the empty substitution.
$\sigma[k \rightarrow v] $ is the substitution where $k$ is mapped to $v$ and others according to $\sigma$ .

\subsubsection{Application of a substitution}
Now we define simultaneously the application of a substitution on values and environments.
\[
\begin{array}{ll}
\multicolumn{2}{l}{\subst{\_}{\_} : \ves{(\cN \times \Val)} \times \Val \ra \Val} \\
\subst{\sigma}{k} & = v \mbox{ if } (k,v) \in \sigma \\
\subst{\sigma}{v \: v_1 \ldots v_n} & = \subst{\sigma}{v} \: \subst{\sigma}{v_1} \ldots \subst{\sigma}{v_n}\\
\subst{\sigma}{\vpi \: x \: v_a \: \cl{b}{\rho}} & = \vpi \: x \: \subst{\sigma}{a_v} \: \cl{b}{\subst{\sigma}{\rho}} \\
\subst{\sigma}{\vlam \: x \: \cl{b}{\rho}} & = \vlam \: x \: \cl{b}{\subst{\sigma}{\rho}} \\
\subst{\sigma}{v} & = v \mbox{ otherwise }
\vs\\
\multicolumn{2}{l}{\substEnv{\_}{\_} : \ves{(\cN \times \Val)} \times \Env \ra \Val} \\
\substEnv{\sigma}{\diamond} & = \diamond \\
\substEnv{\sigma}{(x,v)\rho} & = (x,\subst{\sigma}{v}) \substEnv{\sigma}{\rho} \\
\end{array}
\]

Now we define composition $\compS{\sigma_1}{\sigma_2}$ of two substitutions $\sigma_1$ and $\sigma_2$.
It is assumed that the domains of the substitutions are disjoint and that there are no occurrences of the generic variables of $\sigma_1$ in the values of the co-domain of $\sigma_2$.  
\[
\begin{array}{ll}
\multicolumn{2}{l}{\compS : \ves{(\cN \times \Val)} \times \ves{(\cN \times \Val)} \ra \ves{(\cN \times \Val)}} \\
\compS{((k_1,v_1)\ldots(k_n,v_n))}{\sigma_2} & = ((k_1,\subst{\sigma_2}{v_1})\ldots(k_n,\subst{\sigma_2}{v_n})\: \sigma_2) 
\end{array}
\]

The main part of checking a clause is checking a pattern:
\[
\checkp{(k,\xi,\sigma,\rho_1,\rho_2)}{p}{v}{k',\xi',\sigma',\rho'_1,\rho'_2}{v'}
\]

where
\begin{itemize}
\item
$k$ for a next fresh generic variable
\item
$\rho_1$ and $\rho_2$ environments proving for $x$ a value and its type.
\item
$\xi \subseteq (\cN \times (\Expr \times \Val)$ a list of flexible generic values, along with the inaccessible expressions and its supposed type. We write $k \in \xi$ to mean that there is an element $(k,(e,v)))$ in $\sigma$. 
\item
$\sigma$ an substitution for the flexible generic variables
\item
$p$ : the pattern to check
\item
$v$ : the type of the function that still needs to checked against.
\item
$(k',\xi',\sigma',\rho'_1,\rho'_2){v'}$ are the updated versions of the above return by $\mathbf{checkp}$.
\end{itemize}

We will simultaneously define checking a pattern and a list of patterns.
When checking a constructor $\cc \: \vec{p}$ against its declared type $v$,
we will infer the type of $\cc \: \vec{p}$ by matching $\vec{p}$ against the type of $c$,
yielding a type $v'$. With $inst$ we will match $v$ and $v'$, yielding a substitution for some flexible variables.

\subsubsection{Converting Pattern to value}
During type checking of the patterns, we need to convert patterns to values because the type can depend on them.
Both pattern variables and inaccessible patterns are converted to ascending fresh generic variables.
\[
\begin{array}{ll}

\multicolumn{2}{l}{\ptv{\_}{\_}: \cN \times \Pat \ra \Val}\\
\ptv{k}{p} & = v \mbox{ where } \ptvx \: k \: p = (v,k')
\vs\\ 
\multicolumn{2}{l}{\ptvx : \cN \times \Pat \ra (\Val,\cN)}\\
\ptvx \: k \:x & = (k,k+1) \\
\ptvx \: k \: (\cc \: \diamond) & = (\cc,k) \\
\ptvx \: k \: (\cc \: \vec{p}) & = (\cc \: \vec{v},k') \mbox{ where } (\vec{e},k') = \pstvs \: k \: \vec{p}\\
\ptvx \: k \: (\s p) & = (\s v,k') \mbox{ where } (v,k') = \ptvx \: k \: p\\
\ptvx \: k \: \inacc{e} & = (k,k+1) 
\vs\\
\multicolumn{2}{l}{\pstvs : \cN \times \ves{\Pat} \ra (\ves{\Val},\cN)}\\
\pstvs \: k \: \diamond & = (\diamond,k) \\
\pstvs \: k \: (p \: \vec{p}) & = (k'', v \: \vec{v}) \mbox{ where } \\
& \spcx (v,k') = \ptvx \: k \: p \\
& \spcx (\vec{v},k'') = \pstvs \: k' \: \vec{p}  
\end{array}
\]

\subsubsection{Checking functions}
We here handle the case of a mutual $\fun$ declaration.
A mutual $\cofun$ block is type-checked just the same,
and a single declaration can be seen as special cases of mutual declarations.
To check that the mutual declaration
\begin{bsp}
$\mutual$\\
$\spcx \fun f_1 : t_1 $\\
$\spcx \spc \vec{\gamma}_1$\\
$\spcx \ldots$\\
$\spcx \fun f_n : t_n $\\
$\spcx \spc \vec{\gamma}_n$\\
\end{bsp}
is valid, the following steps are performed:
\begin{enumerate}
\item
for every $i \in \{1 \ldots n \} $
\begin{enumerate}
\item
$\IsType{1}{\diamond}{\diamond}{t_i}$
\item
$v_{t_i} := \wh \cl{t_i}{\diamond}$
\item
$\Sig := \Sig \cup \{f_i \mapsto (v_{t_i},\vec{\gamma_n},\bot)\}$
\end{enumerate}
We check every declared type. The signature is updated, 
but w do not enable reduction because the clauses have yet to be checked. 
\item
for every $i \in \{ 1 \ldots n \} $ and every clause  $ f \vec{p} \: e \: \in \vec{\gamma}_i$:
\begin{enumerate}
\item
$\checkps{1,\diamond,\diamond,\diamond,\diamond}{\vec{p}}{v_{t_i}}{k,\xi,\sigma,\rho_1,\rho_2}{v}$
\item
$\checkinacc{k,\sigma,\rho_1,\rho_2}{i}{e}{v}$ for all $(i,(e,v)) \in \xi$ 
\item 
$\Check{k}{\rho_1}{\rho_2}{e}{v}$
\end{enumerate}
\item
Now that the clauses are checked, we can update the signature to enable reduction of the defined functions.
for every $i \in \{ 1 \ldots n \} $
\begin{enumerate}
\item
$\Sig := \Sig \cup \{f_i \mapsto (v_{t_i},\vec{\gamma_i},\top)\}$
\end{enumerate}
\end{enumerate}

\begin{figure}
\begin{gather*}
% VAR
\nru{\chkpvar}
{v_b = \wh \cl{b}{\ins{\rho}{x}{k}}}
{
\checkp
{k,\xi,\sigma,\rho_1,\rho_2}
{y}
{\vpi \: x \: v_a \: \cl{b}{\rho}}
{k+1,\xi,\sigma,\ins{\rho_1}{y}{k},\ins{\rho_2}{y}{v_a}}
{v_b}}
% CON
\\[2ex]
\nxru{\chkpcon}
{\Sig \: {\cc}=v_c \qquad
\checkps{k,\xi,\sigma,\rho_1,\rho_2}
{\vec{p}}
{v_c}
{k',\xi',\sigma',\rho_1',\rho_2'}
{v'_c}
}
{\unify{k}{\xi}{v'_c}{v_a}{\sigma_2}
\qquad
v_p = \ptv{k}{p}    
\qquad
\sigma'' = \compS{\sigma'}{\sigma_2}
}
{
\rho''_2 = \substEnv{\sigma''}{\rho'_2} \qquad
v_b = \subst{\sigma''}{\wh \cl{b}{\ins{\rho}{x}{v_p}}}
}
{\checkp
{k,\xi,\sigma,\rho_1,\rho_2}
{\cc \: \vec{p}}
{\vpi \: x \: v_a \: \cl{b}{\rho}}
{k',\xi',\sigma'',\rho'_1,\rho''_2}
{v_b}
}
% DOT
\\[2ex]
\nru{\chkpinacc}
{v_b = \wh \cl{b}{\ins{\rho}{x}{k}} , \xi' = \xi \cup \{ (k,(e,v_a)) \} } 
{
\checkp
{k,\xi,\sigma,\rho_1,\rho_2}
{\inacc{e}}
{\vpi \: x \: v_a \: \cl{b}{\rho}}
{k+1,\xi',\sigma,\rho_1,\rho_2}
{v_b}}
\\[2ex]
\nru{}
{}
{
\checkps
{k,\xi,\sigma,\rho_1\rho_2}
{\diamond}
{v}
{k,\xi,\sigma,\rho_1,\rho_2}
{v}}
\\[2ex]
\ndru{}
{\checkp
{k,\xi,\sigma,\rho_1,\rho_2}
{p}
{v}
{k',\xi',\sigma',\rho'_1,\rho'_2}
{v'}
}
{\checkps
{k',\xi',\sigma',\rho'_1,\rho'_2}
{\vec{p}}
{v'}
{k'',\xi'',\sigma'',\rho''_1,\rho''_2}
{v''}
}
{
\checkps
{k,\xi,\sigma,\rho_1\rho_2}
{p \: \vec{p}}
{v}
{k'',\xi'',\sigma'',\rho''_1,\rho''_2}
{v''}}
\end{gather*}
\caption{Phase 1 : checking accessible patterns}
\end{figure}

\begin{figure}
\begin{gather*}
\ndru{}
{
\Check{k}{\rho_1}{\rho_2}{e}{\subst{\sigma}{v_t}}
}
{
(i,v_i) \in \sigma \qquad \EqVal{k}{\nF}{\wh \cl{e}{\rho_1}}{v_i}
}
{
\checkinacc
{k,\sigma,\rho_1,\rho_2}
{i}{e}{v_t}
}
\end{gather*}
\caption{Phase 2: Checking inaccessible patterns}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{\unifyl}
{\nocc{k}{k'}{v}}
{\unify{k}{\xi}{k'}{v}{(k',v)}}
{\; k \in \xi }
\qquad
\nru{\unifyr}
{\nocc{k}{k'}{v}}
{\unify{k}{\xi}{v}{k'}{(k',v)}}
{\; k \in \xi}
\\[2ex]
\nru{\unifyc}
{{\unifylist{k}{\xi}{\vec{v}}{\vec{w}}{\sigma}}}
{\unify{k}{\xi}{\cc \: \vec{v}}{\cc \: \vec{w}}{\sigma}
}
\qquad
\nru{\unifyd}
{{\unifylist{k}{\xi}{\vec{v}}{\vec{w}}{\sigma}}}
{\unify{k}{\xi}{\DD \: \vec{v}}{\DD \: \vec{w}}{\sigma}
}
\\[2ex]
\nru{\unifye}
{\EqVal{k}{N}{v_1}{v_2}}
{\unify{k}{\xi}{v_1}{v_2}{\diamond}
}
\\[2ex]
\nru{}
{}
{\unifylist{k}{\xi}{\diamond}{\diamond}{\diamond}}
\qquad
\ndru{}
{\unify{k}{\xi}{v_1}{w_1}{\sigma}}
{\unifylist{k}{\xi}{\subst{\sigma}{v_2} \ldots \subst{\sigma}{v_n}}{\subst{\sigma}{w_2} \ldots \subst{\sigma}{w_n}}{\sigma'}}
{\unifylist{k}{\xi}{v_1 v_2 \ldots v_n}{w_1 w_2 \ldots w_n}{\compS \sigma \sigma'}}
\end{gather*}
\caption{Instantiation of flexible values by unification}
\end{figure}

\chapter{Termination Checking with the size-change principle}

It is now the right time to formally define what the goal is - that only terminating and productive definitions should be allowed.
\subsubsection{Termination Signatures, Terminating declarations, Productive declarations}
\begin{itemize}
\item
The empty signature is \emph{terminating}.
\item
Given
\begin{itemize}
\item
$\delta = \mutual (\fun f_1 \: \gamma_1) \ldots (\fun f_n \:\gamma_n)$ a mutual inductive declaration
\item
 $\Sigma$ a terminating signature 
\item
$\Sigma'$ the signature resulting from type checking $\delta$ on $\Sigma$. 
\end{itemize}
then $\Sigma'$ is terminating and $\delta$ is \emph{terminating} if and only if for every type-correct closed expression $e$ (given $\Sigma'$) the evaluation $\wh \; \cl{e}{\diamond}$ is defined.  
\item
Given
\begin{itemize}
\item
$\delta = \mutual (\cofun f_1 \:\gamma_1) \ldots (\cofun f_n \:\gamma_n)$ a mutual co-inductive declaration
\item
 $\Sigma$ a terminating signature 
\item
$\Sigma'$ the signature resulting from type checking $\delta$ on $\Sigma$. 
\end{itemize}
then $\Sigma'$ is terminating and $\delta$ is \emph{productive} if and only if for every type-correct closed expression $e$ (given $\Sigma'$) the evaluation $\wh \; \cl{e}{\diamond}$ is defined.  
\item
Given
\begin{itemize}
\item
$\delta$ either a $\clet$ , $\data $ or $\codata$ declaration
\item
$\Sigma$ a terminating signature 
\item
$\Sigma'$ the signature resulting from type checking $\delta$ on $\Sigma$. 
\end{itemize}
then $\Sigma'$ is terminating 
\end{itemize}

If there are missing clauses in a declaration, then evaluation will produce non-canonical values, i.e the computation is stuck. But this does not impact termination.

\section{Matrix notation}

\newcommand{\diag}{\mathrm{diag}}

For a set $R$ we write $R^{m,n}$ for the set of matrices with $n$ rows and $m$ columns and elements in $R$.
We write $\alpha_{i,j}$ for the element in the $j$th row and $i$th column.
For a matrix $\alpha \in R^{m,n}$ we define the length $|\alpha| := (m,n)$.
For a square matrix $\beta \in R^{m,m}$ we define the set of diagonal elements $\diag \beta := \{ \beta_{i,i} \vert i \leq m\}$.
We write $\alpha_{i,j}$ for the element in the $i$-th row and $j$-th column.


\newcommand{\order}{\mathrm{Order}}
\section{Structural recursion}

The order is based on these axioms:
\begin{definition}[Order]
\[ O := \{ < , \leq , ? \} \]
\end{definition}
Axiom1:
\[ e \: < \: C \: \vec{e_1} \: e \: \vec{e_2} \]
\\
Axiom2:
\[ f \: \vec{e} \: \leq \: f \] 

Axiom 2 is needed for higher order data types like $\Ord$.

\subsubsection{Order Addition}
\[
\begin{array}{l | c |c | c }

 +    &  <   &  \leq   &  ? \\
 \hline 
 <    &  <   & <       &  <   \\
 \leq &  <   & \leq    &  \leq \\
 ?    &  <   & \leq    &  ?
\end{array}
\]

\subsubsection{Order multiplication}
\[
\begin{array}{l | c |c | c}
 *   &  <  &  \leq & ? \\
\hline
  <   & <    & <    &   ? \\
 \leq & <    & \leq &   ?  \\
 ?    & ?    & ?    &   ?
\end{array}
\]


\subsubsection{Arity}
For the following definition, we need to enforce that all clauses of a function definition have the same number of patterns.
For function $f$ we define the arity as The arity $ar(f) = \# \vec{p} $ where $f \vec{p} = e $ is some clause.   


\subsubsection{Relating patterns and arguments}

The following definitions are taken from \cite{abelAltenkirch:predStRec}
An expression of the form $\ff \vec{e}$ is called a call.

\newcommand{\mino}{\mathrm{min}\:}
\newcommand{\maxo}{\mathrm{max}\:}
\newcommand{\supo}{\mathrm{sup}\:}
\newcommand{\info}{\mathrm{inf}\:}

\subsubsection{Order minimum}
\[
\begin{array}{l | c |c | c}
 \mino &  <      &  \leq    & ? \\
\hline
  <    & <       &  \leq    &   ? \\
 \leq  & \leq    &  \leq    &   ?  \\
 ?     & ?       &  ?       &   ?
\end{array}
\]

\subsubsection{Order maximum}
\[
\begin{array}{l | c |c | c}
 \maxo & <      &  \leq    &   ? \\
\hline
  <    & <       & <       &   <    \\
 \leq  & <       & \leq    &   \leq  \\
 ?     & <       & \leq    &   ?
\end{array}
\]

\subsubsection{Order supremum}
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\supo : \ves{\order} \ra \order}\\ 
\supo \diamond = \: ? \\
\supo (o \: \vec{o} ) = \maxo o \: (\supo \vec{o}) \\
\end{array}
\]

\subsubsection{Order infimum}
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\info : \ves{\order} \ra \order}\\ 
\info \diamond = \: < \\
\info (o \: \vec{o} ) = \mino o \: (\info \vec{o}) \\
\end{array}
\]

\newcommand{\cmp}{\mathrm{cmp}}
\newcommand{\cmpv}{\mathrm{cmpv}}
\newcommand{\cmps}{\mathrm{cmps}}
\newcommand{\cmpsv}{\mathrm{cmpsv}}
\newcommand{\etp}{\mathrm{etp}\:}

\subsubsection{Comparing pattern to expression}
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmp : \Expr \times \Pat \ra \order}\\ 
\cmp \: e_1 \: \inacc{e_2} & = \cmp e_1 \: p \mbox{ if } \etp e_2 = p \\
\cmp \: x \: p & = \cmpv x \:p  \mbox{ where } x \in \cV \\
\cmp \: (x \: \vec{e}) \: p & = \cmpv x \:p  \mbox{ where } x \in \cV \\
\cmp \: (\cc \: e_1 \ldots e_i) \: (\cc \: p_1 \ldots p_j) & = \info \: (\cmp \: e_1 \: p_1) \ldots (\cmp \: e_m \: p_m)\\
& \: \mbox { where } m = min\{i,j\}\\ 
\cmp \: \cc \: (\cc \: \diamond) & = \: \leq \\\
\cmp \: (f \: \vec{e}) \: f & = \: \leq \mbox{ where } f \in \cV \\
\cmp \: e \: p & = \: ? \mbox{ otherwise}
\end{array}
\]

\subsubsection{Comparing pattern to variable}
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmpv : \cV \times \Pat \ra \order}\\ 
\cmpv \: x \: x & = \: \leq \\
\cmpv \: x \: (\cc \: p_1 \ldots p_n) & = \: < \: * \: \supo \: (\cmpv \: p_1) \ldots (\cmpv \: p_n) \mbox{ if } \cc \mbox{ is inductive }\\   \\
\cmpv \: x \: \inacc{e} & = \: \cmpv \: x \: p \mbox{ if } \etp \: e = p \\
\cmpv \: x \: p & = \: ? \mbox{ otherwise}
\end{array}
\]

\subsubsection{Expression to pattern}
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\etp : \Expr \ra \Pat}\\ 
\etp \: x & = x \\
\etp \: (\cc \: e_1 \ldots e_n ) & = \cc \: (\etp e_1) \ldots (\etp e_n) \\
\etp \: \cc & = \cc \: \diamond \\
\etp \: e & = \stuck \mbox{ otherwise}
\end{array}
\]

Note that co-inductive objects are not well-founded, so  $\cmp x (\cc x) = \: ? $ when $\cc$ is a co-inductive constructor.

\subsubsection{Call matrix}
Let $f \: (p_1 \ldots p_n) \: e$ be a function clause and $g \: (e_1 \ldots e_m$ be a call in $e$.
The associated call matrix is defined by $(f,M,g)$ where $M$ is a $(ar f \times ar g)$ order matrix defined by:
\[ 
\begin{array}[t]{l}
M(i,j) = \cmp \: e_j \: p_i \mbox{ if } j \leq m \\
M(i,j) = \: ? \mbox{ otherwise} 
\end{array}
\]

In the previous definition, we took into consideration that there can be calls $f e_1 \ldots e_n$ where $n < ar f$ because a function might be used in a higher order fashion. We fill up the missing elements with $?$. 

\subsubsection{Call Matrix multiplication}
\[(f,M_1,g) \times (g,M_2,h) := (f,M_1 \times M_2,h)\]

\newcommand{\cg}{\mathrm{cg}\:}
\newcommand{\complete}{\mathrm{complete}\:}

\subsubsection{Call Graph}
A finite set of Call matrices $cg$ is called a \emph{call graph}.
$\cg(\delta)$ is the call graph extracted from a mutual declaration $\delta$.

\subsubsection{Call Graph completion}
$\complete(cg)$ is the completed call graph for a call graph $cg$ 
Call graph completion is closing the set of call matrices under multiplication.
This can be achieved with a fixed-point algorithm.

\section{Size change principle}

The termination criterion in \cite{abelAltenkirch:predStRec} can be replaced with the
simpler and more powerful criterion from \cite{lee01sizechange}
Their formalism is based on bipartite graphs instead of call matrices, but these are
equivalent representations.


\subsubsection{Idempotent matrix}
A call-matrix (f,M,f) is \emph{idempotent} if $ M \times M = M $ 

\subsubsection{Theorem: Size change principle}
Given
\begin{enumerate}
\item
a terminating Signature $\Sigma$
\item
a declaration $\delta$
\item
$\Sigma'$ type-checked
\end{enumerate}
then $\Sigma'$ is terminating and $\delta$ is terminating, if every idempotent call-matrix  $ M \in \complete \: \cg(\delta)$ has a decreasing element in the diagonal.

David Wahlstedt (\cite{wahlstedt:phd:2007}) proofs the soundness of the size-change principle for a dependently typed language 
with first order data types (no function space in constructor arguments, so Axiom 2 is not needed ).
Andreas Abel has shown the soundness of the structural order defined by Axiom 1 and 2 for the simple typed
language foetus.
Note that this order is actually not valid in impredicative systems (\cite{abel:PhD}).

\section{Examples}

Recall the addition function on natural numbers:

\begin{bsp}
$\fun \add : \Nat \ra \Nat \ra \Nat$\\
$\spc \add x \: \zero = x $\\
$\spc \add x \: (\suc y) = \suc (\add x \: y)  $
\end{bsp}
The single recursive call is $\add x \: y$ in the second clause of $add$.
To build the call matrix we need to calculate
\begin{quote}
$\cmp \: x \: x = \: \leq $\\
$\cmp \: x \: (\suc y) = \: ? $\\
$\cmp \: y \: x = \: ? $\\
$\cmp \: y \: (\suc y) = \: < $ 
\end{quote}

\noindent The call set is thus the singleton set with the matrix
\[
M_1 := \add\begin{pmatrix}
\leq & ? \\
?    & < \\
\end{pmatrix}\add
\]

\noindent To complete the call graph, we compose $M_1$ with itself.

\[
\add\begin{pmatrix}
\leq & ? \\
?    & < \\
\end{pmatrix}\add
* 
\add\begin{pmatrix}
\leq & ? \\
?    & < \\
\end{pmatrix}\add
=
\add\begin{pmatrix}
\leq & ? \\
?    & < \\
\end{pmatrix}\add
\]

\noindent which yields an identical matrix.
Thus, we are finished completing and $M_1$ is an idempotent matrix.
As it has a $<$ on the diagonal, the definition for add is terminating.

\noindent Now suppose we switch the arguments in the recursive call:
\begin{quote}
$\fun \add : \Nat \ra \Nat \ra \Nat$\\
$\spc \add x \: \zero = x $\\
$\spc \add x \: (\suc y) = \suc (\add y \: x)  $
\end{quote}

\noindent The call set is then 
\[
M_2 := \addt\begin{pmatrix}

? & \leq \\
< & ?   \\
\end{pmatrix}\addt
\]
Composing $M_2$ with itself yields
\[
M_3 := \addt \begin{pmatrix}
< & ?    \\
? & <    \\
\end{pmatrix} \addt
\] 
which is an idempotent matrix.No further matrix are added during completion.
As $M_3$ has an $<$ on the diagonal, the definition for $\addt$ is also accepted.
Definition with permuted arguments are a strength of the size-change principle.  

\subsection{A mutual definition}

\begin{bsp}
$\mutual$\\
$\spcx \fun \even : \Nat \ra \Bool$\\
$\spcx \spc \even \zero = \tt $\\
$\spcx \spc \even (\suc x) = \odd x $\\
$\spcx \fun \odd : \Nat -> \Bool$\\
$\spcx \spc \odd \zero = \ff$\\
$\spcx \spc  odd (\suc x) = \even x$
\end{bsp}
The call set is 
\[
\even \begin{pmatrix}
< \\
\end{pmatrix}\odd
, 
\odd \begin{pmatrix}
< \\
\end{pmatrix}\even
\] 
In the completed call set includes the idempotent matrices
\[
\even \begin{pmatrix}
< \\
\end{pmatrix}\even
, 
\odd \begin{pmatrix}
< \\
\end{pmatrix}\odd
\] 
which have an decreasing element.
\subsection{Brouwer ordinals}
The so called Brouwer ordinal notations can be defined with
\begin{bsp}
$\data \Ord : \Set$ \\
$\spc \ozero : \Ord $\\
$\spc \olim : (\Nat \ra \Ord ) \ra \Ord $
\end{bsp}
This is an example of a higher-order data type, because the argument to $\olim$ contains a function space.
Now let's define ordinal addition:
\begin{bsp}
$\fun \addOrd : \Ord \ra \Ord \ra \Ord$\\
$\spc \addOrd x \: \ozero = x $\\
$\spc \addOrd x (\olim f) = \olim ( \lam{y} \addOrd  x \: (f \: y))  $
\end{bsp}
The interesting comparison is $(f \: y)$ against $\olim f$.
We have  $f \: y \leq f$ (Axiom 2)and $\olim f < f $ (Axiom 1) thus with transitivity $ f\: y < \olim f$.
And indeed we get:
\begin{bsp}
$\cmp \: x \: x = \leq $\\
$\cmp \: x \: (\olim f) = ? $\\
$\cmp \: (f \: y) \: x = ? $\\
$\cmp \: (f \: y) \: (\olim f) = \cmpv \: f \: (\olim f) = \: < \: * \: \supo \: (\cmpv \: f \: f) = \: < \: * \: \leq = \: < $ 
\end{bsp}
The corresponding call set is thus shown terminating as in the $\add$ case shown above.
\section{Extending the Order}

\subsubsection{Motivation}

The following simple type
\begin{bsp}
$\data \NatP : \Set$\\
$\spc \np : \Nat \ra \Nat \ra \NatP $
\end{bsp}
denotes pairs of natural numbers. Now if one defines a uncurried version of add on pairs:
\begin{bsp}
$\fun \addp : \NatP \ra \Nat$\\
$\spc \addp (\np x \: zero) = x$\\
$\spc \addp (\np x \: (\suc \: y)) = \suc (\addp (\np x \: y))$
\end{bsp}

then this definitions does no longer termination check.
The reason is that too much information is lost when creating the call matrices.

\newcommand{\coll}{\mathrm{collapse}\:}

\subsubsection{Extended Order}
We define the set $O^{+}$ by   
\begin{itemize}
\item
$ O \subseteq O^{+}$
\item
if $ M \subseteq O^{+} , n \in \cN , m \in \cN $ then $M^{n,m} \in O^{+}$
\end{itemize}
and nothing else is in $O^{+}$.

\paragraph{Extended Order operations}
The operations $ *, \mino , \maxo $ given in the previous section are extended by the following additional clauses, using the new operation $\coll : M(O^{+}) \ra O^{+} $:

\[
\begin{array}{ll}
\alpha \: * \beta = \left\{ \begin{array}{l}
                          \alpha \times \beta \mbox{ if } \vert \alpha \vert = \vert \beta \vert \\
                          (\coll \alpha) * (\coll \beta) \mbox{ otherwise}  
                          \end{array}\right. \\
\alpha \: * \: \leq \: = \alpha \\
\alpha \: * \: ? \:    = \: ? \\
\alpha \: * \: < \:    = (\coll \alpha) \: * \: < \\

\vs\\
\maxo \alpha \: \beta =  \left\{ \begin{array}{l}
                          \gamma \mbox{ with } \gamma_{i,j} = \maxo \alpha_{i,j} \: \beta_{i,j} \mbox{ if } \vert\alpha\vert = \vert\beta\vert \\
\\
                          \maxo (\coll \alpha) (\coll \beta) \mbox{ otherwise}  
                          \end{array}\right. \\
\maxo \alpha \: o = \maxo (\coll \alpha) o \mbox{ for } o \in O\\
\maxo o \: \alpha = \maxo o (\coll \alpha) \mbox{ for } o \in O\\

\vs\\
\mino \alpha  \: \beta =  \left\{ \begin{array}{l}
                          \gamma \mbox{ with } \gamma_{i,j} = \mino \alpha_{i,j} \: \beta_{i,j} \mbox{ if } \vert\alpha\vert = \vert\beta\vert \\
\\  
                        \mino (\coll \alpha) \: (\coll \beta) \mbox{ otherwise}  
                          \end{array}\right. \\
\mino \alpha \: o = \mino (\coll \alpha) \: o \mbox{ for } o \in O\\
\mino o \: \alpha = \mino o \: (\coll \alpha) \mbox{ for } o \in O\\

\vs\\
\coll \alpha = \info (\diag \alpha) 
\end{array}
\]

\noindent Now, in the definition of $\cmp$ the clause  
\[
\begin{array}[t]{ll}
\cmp \: (\cc \: e_1 \ldots e_i) \: (\cc \: p_1 \ldots p_j ) & = \: \info \: (\cmp \: e_1 \: p_1) \ldots (\cmp \: e_m \: p_m)\\
& \: \mbox { where } m = min\{i,j\}\\ 
\end{array}
\]
is changed to

\[
\begin{array}[t]{ll}
\cmp (\cc \: e_1 \ldots e_i) \: (\cc \: p_1 \ldots p_j ) & = 
\left\{\begin{array}{l} \gamma \mbox{ with } \gamma_{i,j} = \cmp \: e_i \: e_j \\
\: \mbox{ if } i = j \geq 2 \\
\\
\info (\cmp \: e_1 \: p_1) \ldots (\cmp \: e_m \: p_m)\\
\: \mbox { where } m = min\{i,j\} \mbox{ otherwise } 
\end{array}
\right.
\end{array}
\]
so more information about the components is used during termination checking for as long as possible.

\subsubsection{Decreasing element}
In the extended order, a decreasing element is recursevly defined by
\begin{itemize}
\item
$<$ is decreasing
\item
$M$ is decreasing if $\diag(M)$ has at least one decreasing element.
\end{itemize}

\subsubsection{Example}

\subsection{Outlook : Huet list reversion}
First, we present a peculiar list reversion algorithm.

The algorithm cannot be verified terminating.
Note the call 
\[\rev A \: (\revb A \: x \: xs)\]
is not structural recursive.
A termination checker would need the information about $\revb$.
We can fix this by using vectors instead of lists. Now the termination checker can verify the termination, because the algorithm is structurally recursive on the size of the vector.
So we note that better type information helps the termination checker by making more definitions structurally recursive.

But using vectors instead of lists is not always easily possible.
Consider a filter function on Lists. We only know that this function does not increase the size, but
we don't know the exact length.
This is one of the reasons we will introduce a special size type in the next chapter.

\begin{figure}
$\mutual $  \\
$ \spc \fun \rev : \EPi{A}{\Set}{\List A \ra  \List A} $ \\
$ \spc \spc \rev .A \: (\nil A ) = \nil A$\\
$ \spc \spc \rev .A \: (\cons A \:x  \: xs) = \cons A \: (\reva A \: x \: xs) (\revb A \: x \: xs)$\\
$\ \spc \fun \reva : \EPi{A }{\Set}{A  \ra \List A \ra A}$\\
$ \spc \spc \reva .A \: a \: (\nil A ) = a$ \\
$\spc \spc \reva .A \: a (\cons A \: x \: xs) = \reva A \: x \: xs$\\
$\spc \fun \revb : \EPi{A}{\Set}{ A \ra \List A \ra \List A} $\\
$\spc \spc \revb .A \: a \: (\nil A ) = \nil A $\\
$\spc \spc \revb .A \: a (\cons A\:  x \: xs) = \rev A (\cons A \: a \: (\rev A \: (\revb A \: x \: xs)))$

\caption{reversion on Lists}  
\end{figure}
\begin{figure} 
$\mutual $ \\
$\spc \fun \rev : \EPi{n}{\Nat }{\EPi{A}{\Set }{\vVec A \: n \ra \vVec A \: n}}$\\
$\spc \spc \rev .\zero \: .A  \: (\nil A) = \nil A $\\
$\spc \spc \rev .(\suc n) .\: A (\cons A \: n \: x \: xs) = $\\
$\spcx \cons A \: n \: (\reva n \: A \: x \: xs) (\revb n \: A \: x \: xs) $ \\
$\spc \fun \reva : \EPi{n}{\Nat}\EPi{A}{\Set}{A \ra Vec A \: n \ra A}$\\
$\spc \spc \reva .\zero  \: .A \: a \: (\nil A) = a $\\
$\spc \spc \reva .(\suc n) .A \: a \: (\cons A \: n \: x \: xs) = \reva n \: A \: x \: xs $\\
$\spc \fun \revb : \EPi{n}{\Nat}{\EPi{A}{\Set}{A \ra \vVec A \: n \ra \vVec A \: n}}$\\
$ \spc \spc \revb .\zero \: .A  \: a \: (\nil A) = \nil A $\\
$ \spc \spc \revb .(\suc n) \: .A \: a (\cons A \: n \: x \: xs) = $\\
$ \spcx \rev (\suc n) A (\cons A \: n \: a (\rev \: n A \: (\revb \: n A \: x \: xs))$
\caption{reversion on vectors}  
\end{figure}  

\chapter{Sized Data Types}
Traditionally, size annotation have been used in the typing rules.
We take a different approach.
Wie add a primitive size type, and then use the current termination checker to see that the size is 
decreasing.

\section{Adding a size type}
\subsubsection{Syntax}
We expand expressions and patterns:
\[
\begin{array}{lrll}
\Expr \ni e,A,B & ::= & \ldots & \\
& \mid & \Size & \mbox{size type} \\
& \mid & \s e  & \mbox{size successor}\\ 
& \mid & \infty & \mbox{limit size}\\
\end{array}
\]

\subsubsection{Patterns}
\[
\begin{array}{lrll}
\Pat \ni p & ::= & \ldots & \\
& \mid & \s p & \mbox{size successor pattern}\\
\end{array}
\]


As $\Size$ is a type, in particular we also have variables and patterns of type $\Size$.
Thus, we can form expressions of type $\Size$ in the style of Barthe.

\subsubsection{Semantics}

Values also are expanded
\[
\begin{array}{lrll}
\Val \ni v & ::= & \ldots & \\
& \mid & \Size & \mbox{size type value}\\
& \mid & \s v & \mbox{size successor}\\
& \mid & \infty & \mbox{size limit}\\
\end{array}
\]

\subsubsection{Evaluation}

\[
\begin{array}{ll}
\wh \cl{\Size}{\rho} & = \Size \\
\wh \cl{\infty}{\rho} & = \infty  \\
\wh \clp{\s e}{\rho} & = \sinfty \: v \mbox{ where } \: v = \wh \cl{e}{\rho} \\ 
\end{array}
\]

\subsubsection{Size successor}
We should take into account that $\infty$ is the limit size, i.e the equation $\s \infty = \infty$:
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\sinfty : \Val \ra \Val}\\ 
\sinfty \: \infty & = \infty\\
\sinfty \:  v & = \s v  \mbox{ otherwise}\\ 
\end{array}
\]

\subsubsection{Pattern matching}
\[
\begin{array}{ll}
\matchf \: \rho \: (\s p) \: \infty & = \match \: \rho \: p \: \infty \\
\matchf \: \rho \: (\s p) \: (\s v) & = \match \: \rho \: p \: v \\
\end{array}
\]

\subsubsection{Type Checking}

Application of a substitution needs on additional clause:
\[
\begin{array}{ll}
\subst{\sigma}{\s v} & = \sinfty \subst{\sigma}{v} \\
\end{array}
\]

All additional typing rules are shown in figure \ref{str}.
\begin{figure}
\begin{gather*}
\nru{}{}{\IsType{k}{\rho_1}{\rho_2}{\Size}}
\qquad
%% Succ
\nru{\chksucc}
{\Check{k}{\rho_1}{\rho_2}{e}{\Size}}
{\Check{k}{\rho_1}{\rho_2}{\s e}{\Size}} 
%% Infty
\\[2ex]
\nru{\infinfty}{}{\Infer{k}{\rho_1}{\rho_2}{\infty}{\Size}} 
%% Succ
\\[2ex]
\nru{\eqsuc}
{\EqVal{f}{k}{v_1}{v_2}}
{\FeqVal{f}{k}{\s v_1}{\s v_2}}
% SUCC
\\[2ex]
\nru{}
{\nocc{k}{a}{v}}
{\nocc{k}{a}{\s v}}
\qquad
\nru{}
{\spos{k}{i}{v}}
{\spos{k}{i}{\s v}}
\\[2ex]
\ndru{\chkpsucc}
{
\checkp{k,f,\sigma,\rho_1,\rho_2}{p}{\Size \ra \Size}
{k',f',\sigma',\rho'_1,\rho'_2}{v'}}
{
\EqVal{k'}{\nF}{v_a}{v'} \qquad
\ptv{k}{p} = v
}
{
\checkp
{k,f,\sigma,\rho_1,\rho_2}
{\s p}
{\vpi x v_a \cl{b}{\rho}}
{k',f,\sigma,\ins{\rho_1}{y}{k},\ins{\rho_2}{y}{v_a}}
{\wh \cl{b}{\ins{\rho}{x}{v}}}}
\\[2ex]
\nru{\unifys}
{\unify{k}{f}{v_1}{v_2}{\sigma}}
{\unify{k}{f}{\s v_1}{\s v_2}{\sigma}
}
\\[2ex]
\nru{\unifyi}
{\unify{k}{f}{v_1}{\infty}{\sigma}}
{\unify{k}{f}{\s v_1}{\infty}{\sigma}
}
\end{gather*}
\label{str}
\caption{Additional typing rules for size}
\end{figure}

\subsection{Structural order}

\subsubsection{Expression to pattern}
has the additional case
\[
\begin{array}[t]{ll}
\etp (\s e) = \s (\etp e) \\
\end{array}
\]

\subsubsection{Comparing pattern to expression}
is extended by one case
\[
\begin{array}[t]{ll}
\cmp (\s e_1) \: (\s e_2) & = \cmp e_1 \: e_2 \\
\end{array}
\]

\subsubsection{Comparing pattern to variable}
the size successor is treated like an inductive constructor:
\[
\begin{array}[t]{ll}
\cmpv x \: (\s p) & = \: < * \: (\cmpv x \: p)\\
\end{array}
\]

This is quite dangerous, as the size type is not well-founded.
It has an infinite height element $\infty$ and no bottom. 
After defining what a sized type is and some examples, we will have to reign in the use of the size type
so the size change principle stays valid.


\section{Sized data type declarations}

\newcommand{\sizecon}[4]{#1\vdash#2\mbox{ \textbf{sizeCon} }#3\:#4}
\newcommand{\sizeuse}[4]{#1\vdash#2\mbox{ \textbf{sizeUse} }#3\:#4}


Two new declarations are added to the language:
\subsubsection{Declarations}
\[
\begin{array}{lrll}
\Decl \ni \delta & ::= & \ldots & \\
& \mid & \sized \data \DD \tau : A \vec{\gamma} & \mbox{sized inductive data type}\\ 
& \mid & \sized \codata \DD \tau : A \vec{\gamma} & \mbox{sized co-inductive data type} \\
\end{array}
\]

A sized data declaration need to be of the following scheme:
\begin{bsp}
$\sized \data \DD ( p_1 : P_1) \ldots ( p_n : P_n) : \Size \ra \Gamma \ra \Set $\\
$\spc \ldots$\\
$\spc \cc : (i : \Size) \ra \Delta \ra \DD \: p_1 \ldots p_n \: (\s i) \: t_2 \ldots t_m$\\
$\spc \ldots$\\   
\end{bsp}
For normal data declarations, a size was not allowed in the indices $\Gamma$ because $\Size$ is not a small type.
In addition, we will check that every recursive argument in $\Delta$ has the form $\DD \ldots i \ldots $ and $i$ does not appear anywhere else. The size argument denotes the height of an object of the type when viewed as a tree. Every constructor adds to this height.

\subsubsection{Type-checking sized data declaration}

To check that the sized data declaration
\[\begin{array}{l}
\data \DD \tau : \Size \ra A \\
\spcx \vec{\gamma}
\end{array}
\]
is valid, the following steps are performed: 
\begin{enumerate}
\item
$\DataType{1}{\diamond}{\diamond}{\mid\tau\mid+1}{\tau \ra \Size \ra A}$
\item
$v_D := \wh \clp{\tau \ra \Size \ra A}{\diamond}$
\item
$\Sig := \Sig \cup \{\DD \mapsto v_D\}$
\item
for every constructor declaration $\cc : B  \in \vec{\gamma}$:
\begin{enumerate} 
\item
$\ConType{1}{\diamond}{\diamond}{\mid\tau\mid}{\tau \ra B}$
\item
$v_C := \wh \clp{\tau \ra B}{\diamond}$
\item
$\sposc{1}{v_C}{i}$ for every $i \in \pos(\DD) $ 
\item
$\sposc{1}{v_C}{\DD}$
\item
$\sizecon{1}{v_c}{i}{\DD}$
\item
$\Sig := \Sig \cup \{\cc \mapsto v_C\}$
\end{enumerate}
\end{enumerate}

\begin{figure}
\begin{gather*}
\ndru{}
{\nocc{k}{p_j}{i} \mbox { for all } j \in \{ 1 \ldots n\}}
{\nocc{k}{t_k}{i} \mbox { for all } k \in \{ 1 \ldots m\}}
{\sizeuse{k}{\DD \: p_1 \ldots p_m \: i \: t_2 \ldots t_m}{i}{\DD}}
\\[2ex]
\ndru{}
{\sizeuse{k}{v}{i}{\DD}}
{\sizeuse{k}{v_1}{i}{\DD} \mbox { for all } k \in \{ 1 \ldots n\}}
{\sizeuse{k}{v \: v_1 \ldots v_n}{i}{\DD}}
\\[2ex]
\nru{}
{\sizeuse{k}{v}{i}{\DD}}
{\sizeuse{k}{\s v}{i}{\DD}}
\qquad
\ndru{}
{\sizeuse{k}{v_a}{i}{\DD}}
{\sizeuse{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{i}{\DD}}
{\sizeuse{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}{i}{\DD}}
\\[2ex]
\nru{}
{\sizeuse{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{i}{\DD}}
{\sizeuse{k}{\vlam \: x \: \cl{b}{\rho}}{i}{\DD}}
\qquad
\nru{}
{v \neq i}
{\sizeuse{k}{v}{i}{\DD}}
\\[2ex]
\nxru{}
{\sizeuse{k}{v_a}{i}{\DD} \mbox{ if } k > i}
{v_a = \Size \mbox { if } k = i }
{\sizecon{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{\DD}}
{\sizecon{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}{i}{\DD}}
\qquad
\nru{}
{}
{\sizecon{k}{\DD \:p_1 \ldots p_n \: \s i \:t_2 \ldots t_m}{i}{\DD}}
\end{gather*}
\caption{constructor size check}
\end{figure}

\subsection{Example : Sized natural numbers}
\begin{bsp}
$\sized \data \SNat : \Size \ra \Set $ \\
$\spcx \zero : \EPi{i}{\Size}{ \SNat \: \s i} $\\
$\spcx \suc : \EPi{i}{\Size}{ \SNat \: i \ra \SNat \: \s i} $
\end{bsp}

\section{Sub-typing for size}
It would be quite nice to have sub-typing on sized data types.
As we are only interested in size arguments getting smaller, 
In one call to the function, the size might decrease by one, in another clause, by two.
It is enough for termination to decrease by one.
For inductive sized types like $\SNat$ we want for every size $i$
\begin{bsp}
$\SNat A\: i$ is a subtype of $\SNat A \: \s i$
\end{bsp}
and
\begin{bsp}
$\SNat A\: i$ is a subtype of $\SNat A \: \infty$.
\end{bsp}
because for inductive types the size is an upper bound for its height.
For co-inductive sized types like $\Stream$ we want for every size $i$
\begin{bsp}
$\Stream \s i $ is a subtype of $\Stream i$
\end{bsp}
and
\begin{bsp}
$\Stream \infty$ is a subtype of $\Stream i$.
\end{bsp}
because for co-inductive types the size is a lower bound for its definedness.
There is natural order on size values: 
\[\SzLeq{v_1}{v_2} \subseteq \Val \times \Val \]
Now the subtype relation is defined similar to the equality relation by two simultaneous judgments:
\[\LeqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times \Val \times \Val \]
\[\FleqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times\Val \times \Val \]
Of special interest are the rules:
\begin{itemize}
\item
$\leqappind$: sub-typing for sized inductive type 
\item
$\leqappco$: sub-typing for sized co-inductive type
\item
$\leqappd$: sub-typing for other data types
\item
$\leqpi$: sub-typing for function space. 
\end{itemize}
The domain of the function space is antitone, thus we values to be checked switch place.
In accordance, we switch $f$.
We define $\overline{\rF}=\lF$,  $\overline{\lF}=\rF$ ,  $\overline{\nF}=\nF$.
\begin{figure}
\begin{gather*}
\nru{\sleqinfty}
{}
{\SzLeq{v}{\infty}}
\qquad
\nru{\sleqgen}
{}
{\SzLeq{k}{k}}
\\[2ex]
\nru{\sleqsucci}
{\SzLeq{v_1}{v_2}}
{\SzLeq{\s v_1}{\s v_2}}
\qquad
\nru{\sleqsuccii}
{\SzLeq{v_1}{v_2}}
{\SzLeq{v_1}{\s v_2}}
\end{gather*}
\caption{Size comparison}
\end{figure}

\begin{figure}
\begin{gather*}
%% Force
\nxru{\eqforce}
{\FleqVal{\lF}{k}{\forc \; v_1}{v_2} \qquad \mbox{if } \forc \: v_1 \neq v_1 , \forc \: v_2 = v_2  , f \neq \rF
}
{\FleqVal{\rF}{k}{v_1}{\forc \; v_2} \qquad \mbox{if } \forc \: v_1 = v_1 , \forc \: v_2 \neq v_2 , f \neq \lF }
{\FleqVal{f}{k}{v_1}{v_2} \qquad \qquad \qquad \qquad \qquad \mbox{ otherwise}}
{\LeqVal{f}{k}{v_1}{v_2}}
\\[2ex]
%% Ind Data
\ndru{\leqappind}
{\mbox{for all } i \in \pos(\DD): \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\mbox{for all } j \notin \pos(\DD): \EqVal{f}{k}{p_j}{q_j} 
}
{\mbox{for all } k \in \{1,..m\}: \EqVal{f}{k}{v_k}{w_k}
\qquad
\SzLeq s t }
{\FleqVal{f}{k}{\DD \: p_1 \ldots p_n \: s \: v_1 \ldots v_m}{\DD \: q_1 \ldots q_n \: t \: w_1 \ldots w_m}}
%% Co Data
\\[2ex]
\ndru{\leqappco}
{\mbox{for all } i \in \pos(\DD): \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\mbox{for all } j \notin \pos(\DD): \EqVal{f}{k}{p_j}{q_j}}
{\mbox{for all } k \in \{1,..m\}:\EqVal{f}{k}{v_k}{w_k}
\qquad
\SzLeq t s }
{\FleqVal{f}{k}{\DD \: p_1 \ldots p_n \: s \: v_1 \ldots v_m}{\DD \: q_1 \ldots q_n \: t \: w_1 \ldots w_m}}
%% Data
\\[2ex]
\ndru{\leqappd}
{\mbox{for all } i \in \pos(\DD): \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\mbox{for all } j \notin \pos(\DD): \EqVal{f}{k}{p_j}{q_j}}
{\mbox{for all } k \in \{1,..m\}:\EqVal{f}{k}{v_k}{w_k}}
{\FleqVal{f}{k}{\DD \: p_1 \ldots p_n v_1 \ldots v_m}{\DD \: q_1 \ldots q_n w_1 \ldots w_m}}
%%App
\\[2ex]
\nru{\leqapp}
{\LeqVal{f}{k}{v_1}{v_2} \qquad
\EqVal{f}{k}{c_1}{d_1} \ldots \EqVal{f}{k}{c_n}{d_n}}
{\FleqVal{f}{k}{v_1 (c_1 \ldots c_n)}{v_2 (d_1 \ldots d_n)}}
%% Pi
\\[2ex]
\nru{\leqpi}
{\LeqVal{\overline{f}}{k}{a_2}{a_1}
\qquad
\LeqVal{f}{k+1}{\wh \cl{b_1}{\ins{\rho_1}{x_1}{k}}}{\wh \cl{b_2}{\ins{\rho_2}{x_2}{k}}}}
{\FleqVal{f}{k}{\vpi \: x_1 \: a_1 \: \cl{b_1}{\rho_1}}{\vpi \: x_2 \: a_2 \: \cl{b_2}{\rho_2}}}
%% Lam
\\[2ex]
\nru{\leqlam}
{\LeqVal{f}{k+1}{\wh \cl{b_1}{\ins{\rho_1}{x_1}{k}}}{\wh{b_2}{\ins{\rho_2}{x_2}{k}}}}
{\FleqVal{f}{k}{\vlam \: x_1 \: \cl{b_1}{\rho_1}}{\vlam \: x_2 \: \cl{b_2}{\rho_2}}}
\\[2ex]
\nru{\leqsuc}
{\LeqVal{f}{k}{v_1}{v_2}}
{\FleqVal{f}{k}{\s v_1}{\s v_2}}
%% Atom
\qquad
\nru{\leqatom}
{}
{\FleqVal{f}{k}{a}{a}}
\end{gather*}
\caption{subtype checking}
\end{figure}

\section{Sized Inductive types }

\subsection{Natural number division}

The minus function can be defined by:
\begin{bsp}
$\fun \minus : (i : \Size ) \ra \SNat i \ra \SNat \infty \ra \SNat i$\\
$\spc \minus \inacc{\s i} \: (\zero i) \:  y = zero i $ \\
$\spc \minus i \: x \: (\zero .\infty)  = x $\\
$\spc \minus \inacc{\s i} \: (\suc \: i \: x) \: (\suc \inacc{\infty} \: y) = \minus i \: x \: y $
\end{bsp}
While $\minus$ is structurally recursive even without a size, 
there is more information in the type: the results size is at most as big as the first input.

This is essential to see that division on natural numbers (with division by zero defined to be zero) 
is terminating:
\begin{bsp}
$\fun \div : ( i : \Size )  \ra  \SNat i \ra \SNat \infty \ra \SNat i$\\
$\spc \div \inacc{\s i} \: (\zero i) \: y = \zero i$\\
$\spc \div \inacc{\s i} \: (\suc i \: x) (\zero \inacc{\infty})  = \zero i$\\
$\spc \div \inacc{\s i} \: (\suc i \: x) (\suc \inacc{\infty}) \: y) = $\\
$\spc \spcx \suc i \: (\div i \: (\minus i \: x \:y) \: (\suc \infty \: y))$
\end{bsp}
$\div$ is structural recursive on the size argument.
To be type correct,it is needed that $(\minus i \: x \:y)$ has the type $\SNat i$.

\section{Sized Lists}
\begin{bsp}
$\sized \data \List ( A : \Set ) : \Size \ra \Set $ \\
$\spcx \nil : \EPi{i}{\Size}{ \List A \: \s i} $\\
$\spcx \cons : \EPi{i}{\Size}{ A \ra \List A \: i \ra \List A \: \s i} $
\end{bsp}

What is the difference between vectors and sized lists ?
The size index is only used for relative comparisons, its not an exact number, but an upper bound.
This enables sub-typing, and one can compromise by forgetting the exact size ($\infty$).
For example, splitting a vector of length n, we need to show that there exist j,k such that $j+k = n$.
With sized type, we don't need to be that exact.

\subsubsection{Quicksort}
\begin{bsp}
$\data \ProdT ( + A : \Set) : \Set$\\
$\spc  \prd : A \ra A \ra \ProdT A$\\

$\fun \pra : ( A : \Set ) \ra \ProdT A\: \ra A$\\
$\spc \pra \inacc{A}\: (\prd A\: a \: b) = a$\\

$\fun \prb : ( A : \Set ) \ra \ProdT A\: \ra A$\\
$\spc \prb \inacc{A}\: (\prd A\: a \: b) = b$\\

$\fun \ite : (A : \Set ) \ra \Bool \ra A \ra A \ra A$\\
$\spc \ite A\: \ttt a\: b\: = a$\\
$\spc \ite A\: \fff a\: b\: = b$\\
\end{bsp}

The $\pivot$ function splits a list $l$ in two list $l_1$ and $l_2$ where all smaller elements are in $l_1$ and the others in $l_2$.
The type of the function allows a rough upper bound on the sizes of the result lists.
\begin{bsp}
$\fun \pivot : (i : \Size ) \ra (A : \Set ) \ra ( leq : A \ra A \ra \Bool ) $\\
$\spcx	\spcx \ra A \ra \List A \: i \ra \ProdT (\List A \: i)$\\
$\spc \pivot \inacc{\s i} \: \inacc{A} \: leq \: a \: (\nil A \: i) = \prd (\List \: A \: \s i) (\nil A \: i) (\nil A \: i)$\\
$\spc \pivot \inacc{\s i} \: \inacc{A} \: leq \: a \: (\cons A \: i \: x \:xs) = $\\ 
$\spc \spc \ELet{rec}{\ProdT (\List A \:i)}{\pivot i \: A \: leq \: a \: xs}$\\
$\spc \spc \ELet{l_1}{\List A \:i}{\pra (\List A \: i) \: rec}$\\
$\spc \spc \ELet{l_2}{\List A \:i}{\prb (\List A \: i) \: rec}$\\  
$\spc \spcx  \ite (\ProdT (\List A \: \s i)) (leq \: a \: x)  $\\
$\spc \spcx  \spc \prd (\List A \: \s i) \: l_1 \: (\cons A \: i \: x \: l_2)$\\
$\spc \spcx  \spc \prd (\List A \: \s i) \: (\cons A \: i \: x \: l_1) \: l_2$\\
\end{bsp}

Now we can define quicksort:
\begin{bsp}
$\fun \qsapp : (i : \Size ) \ra ( A : \Set ) \ra ( leq : A \ra A \ra \Bool) $\\
$\spcx \spcx \ra \List A \: i \ra \List A \: \infty \ra \List A \: \infty$\\
$\spc \qsapp \inacc{\s i} \: \inacc{A} \: leq \: (\nil A \: i) \:             ys = ys$\\
$\spc \qsapp \inacc{\s i} \: \inacc{A} \: leq \: (\cons A \: i \: x \: xs) \: ys = $\\
$\spc \spc  \ELet{sl}{\ProdT (\List A \:i)}{\pivot i \: A \: leq \: x \: xs}$\\
$\spc \spc  \ELet{l_1}{\List A \: i}{\pra (\List A \: i) \: sl}$\\
$\spc \spc  \ELet{l_2}{\List A \: i}{\prb (\List A \: i) \: sl}$\\
$\spc \spcx \qsapp i \: A \: leq \: l_1 \: (\cons A \: \infty \: x \: (\qsapp i \: A \: leq \: l_2 \: ys))$\\

$\clet \quicksort : (i : \Size ) \ra (A : \Set ) \ra (\lleq : A \ra A \ra \Bool)$\\ 
$\spcx \spcx \ra \List A\: i \ra \List A\: \infty$\\
$\spcx = \lam{i}\lam{A}\lam{leq}\lam{l} \qsapp i\: A\: leq \: l \: (\nil A\: \infty)$ 
\end{bsp}
where the helper function $\qsapp$ sorts the first list and appends it to an already sorted list.

\subsection{Sized ordinal numbers}
Sized types are quite powerful. 
One can show the termination of ordinal addition with a decreasing size argument.
First, sized Brouwer Ordinals:
\begin{bsp}
$\sized \data \Ord : \Size \Set$ \\
$\spcx \ozero : (i : \Size ) \ra \Ord \s i $\\
$\spcx \olim : ( i : \Size ) \ra (\Nat \ra \Ord i) \ra \Ord \s i $
\end{bsp}
Now we don't kneed axiom 2 of the structural ordering to see that addition is terminating:
\begin{bsp}
$\fun \addOrd : \Ord \infty \ra \EPi{i}{\Size}{\Ord i \ra \Ord \infty }$\\
$\spc \addOrd x\: \inacc{\s i}\: (\ozero i) = \ozero i $\\
$\spc \addOrd x\: \inacc{\s i}\: (\olim f)  = \olim \infty ( \lam{y} \addOrd  x \: i \: (f \: y))  $
\end{bsp}
$\addOrd$ is structurally recursive in the size argument.
\subsection{A higher-order function}
While somewhat artificial, the following example is interesting for two reasons:
\begin{bsp}
$\fun \addWith : ((k : \Size ) \ra \SNat k \ra \SNat k ) \ra (i : \Size ) \ra (j : \Size ) $\\
$\spcx \spcx \ra  \SNat i \ra \SNat j \ra \SNat \infty $\\
$\spc \addWith f \: \inacc{\s i} \: j \: (\zero i) \: y = y $ \\
$\spc \addWith f \: \inacc{\s i} \: j \: (\suc i \: x) \: y = \suc \infty \: (\addWith f \: j \: i \: y \: (f \: i \: x))$
\end{bsp}
$\addWith$ resembles the permuting size add function we've discussed in the previous chapter.
But it has one additional parameter that is declared to be a size-preserving function.
This is one strength of sized types: Any function of type 
\[ (k : \Size ) \ra \SNat k \ra \SNat k \]
can now be passed along to $\addWith$.
The second reason is that the function has two size arguments that are permuting in the recursive call. 
So this is really one example that plays to the strength of our system: both the size type and the size change principle are needed.

\section{Sized co-inductive types}


There are syntactic criteria for checking productivity of co-inductive definition's.
But in the following, we will use the size type to prove productivity.

\subsection{Sized Streams}

We introduced the stream type already in chapter 2.
An example of an unproductive stream is $\unp$:
\begin{bsp}
$\cofun \unp : \Stream $ \\
$\spc \unp = \unp$
\end{bsp}
We can look at any element of $\zeroes$ .
But looking at a element $\unp$ is not defined. 
A syntactic criterion for productivity of co-inductive definitions is the guardedness condition:
Every (co)recursive call is surrounded by at least one constructor, and nothing else.
In the above example , the call to $\zeroes$ is guarded by $\cons$
But we want to use sized types for productivity checking.

Let us now explain how sized types , in combination with the current terminating criterion, can be used for showing productivity.
First we introduce the sized co-inductive type 
\begin{bsp}
$\codata \Stream : \Size \ra \Set $ \\
$\spc \cons : \EPi{i}{\Size}{\Nat \ra \Stream i \: \ra \Stream \s i } $
\end{bsp}
For the productive stream $\zeroes$, we turn it into
\begin{bsp}
$\cofun \zeroes: \EPi{i}{Size}{\Stream i} $ \\
$\spc \zeroes \s i = \cons i \zero (\zeroes i)$\\
\end{bsp}
The termination checker sees that the recursive call happens on a smaller size.
For the unproductive stream, we have two bad choices:
The first one
\begin{bsp}
$\cofun \unp : \EPi{i}{\Size}{\Stream i}$ \\
$\spc \unp i =  \unp i$
\end{bsp}
is type correct, but the call is not on a smaller size.
The second option is
\begin{bsp}
$\cofun \unp : \EPi{i}{\Size}{\Stream i}$ \\
$\spc \unp \s i = \unp i $
\end{bsp}
is accepted by the termination checker, but is not type correct.

Now,for a productive stream, we can look at the first element of a stream with $\head$, or remove the first element of a stream with $\tail$:
\begin{bsp}
$\fun \head : \Stream \infty \ra \Nat$\\
$\spc \head \: (\cons \: \inacc{\infty} \: x \: xs) = x$

$\fun \tail :  \Stream \infty \ra \Stream \infty $\\
$\spc \tail \: (\cons \: \inacc{\infty} \: x \: xs) = xs$\\
\end{bsp}

We can now define the $n$th element of a Stream, starting with zero:
\begin{bsp}
$\fun \nth : \Nat \ra \Stream \infty \ra \Nat$\\
$\nth \zero xs = \head \infty xs$\\
$\nth (\suc n) \: xs = \nth n (\tail \infty xs)$\\
\end{bsp}
\subsection{Fibonacci stream}

The obligatory example is to define the stream of Fibonacci numbers:
\begin{bsp}
$\cofun \fibs : \Nat \ra \Nat \ra \EPi{i}{\Size}{\Stream i}$\\
$\spc  \fibs x \: y \: \s i = \cons i \: x \: (\fibs y \: (\add x \: y) \: i)$\\

$\clet \fib : \Stream \infty = \fibs (\suc \zero) \: (\suc zero) \: \infty$
\end{bsp}
and get the fourth Fibonacci number by:
\begin{bsp}
$\clet \fibf : \Nat = \nth (\suc (\suc (\suc (\suc \zero )))) \: (\fib \infty)$
\end{bsp}

\subsection{Equality on streams}
The following is a valid definition:
\begin{bsp}
$\clet \eqo : \Eq (\Stream \infty) (\zeroes \infty) (\cons \infty \zero (zeroes \infty))$\\
$\spc = \refl (\Stream \infty) (zeroes \infty)$
\end{bsp}
The inferred type of $\refl (\Stream \infty) \: (\zeroes \infty)$ is 
\[\Eq (\Stream \infty) \: (\zeroes \infty) \: (\zeroes \infty)\]
The type checker has to unroll $(\zeroes \infty)$ once to see that the type is equal to 
\[
\Eq (\Stream \infty) \: (\zeroes \infty) \: (\cons \infty \: \zero (\zeroes \infty)
\]
Now let's define another stream
\begin{bsp}
$\cofun \zeroest: \EPi{i}{Size}{\Stream i} $ \\
$\spc \zeroest (\s \s i) = \cons \s i \zero (\cons i \zero (\zeroest i))$\\
\end{bsp}
We cannot prove \[\Eq (\Stream \infty) (\zeroes \infty)) (\zeroest \infty)\]
because the type checker can't unroll both $\zeroes \infty)$ and $\zeroest \infty$ as
this would lead to no progress.
But we can define co-inductive equality  on streams \cite{coquand-infinite}
\begin{bsp}
$\codata \beqd : \Size \ra \Stream \infty \ra \Stream \infty \ra \Set$\\
$ \spcx \beq : (i : \Size ) \ra ( n : \Nat ) \ra (s_1 : \Stream \infty ) \ra (s_2 : \Stream \infty )$\\
$ \spcx \spc  \ra \beqd i \: s_1 \: s_2 \ra \beqd (\cons n \: s_1) \: (\cons n \: s_2)$
\end{bsp}
Note that $\beqd$ is a sized co-inductive predicate.
and now the following is a valid infinite proof:
\begin{bsp}
$\cofun \eqt : (i : \Size ) \ra \beqd i (\zeroes \infty) (\zeroest \infty)$\\
$\spc \eqt (\s \s i) = $\\
$\spc \spcx \beq \s i \: \zero (\cons \infty \: \zero (\zeroes \infty)) \: (\cons \infty \zero (\zeroest \infty))$\\ 
$\spc \spcx \spc (\beq i \: \zero (\zeroes \infty) \: (\zeroest \infty) \: (\eqt i))$
\end{bsp}

\section{Admissibility}


The use of sizes needs to be constraint.
We will give a criteria for when a mutual declaration $\delta$ is admissible.
This should mean that the size type is used in valid ways.
Admissibility is a necessary concept in works on sized types.
Gimenez and Barthe deal with monotonicity criteria.
Abel and Pareto have worked on the more advanced concept of f continuity.

All these criteria look at the type of the declared functions to decide admissibility.
Our criterion is based on monotonicity and has to deal with the peculiarities of
dependent pattern matching. We look at the types of a mutual declaration, but 
also at the patterns : Matching on constructors has an influence on the type.  

Consider for example the function definition
\begin{bsp}
$\fun \bad : \EPi{i}{\Size}{\Nat}$\\
$\spc \bad \s i = \bad i $ 
\end{bsp}
It is type correct, and the termination checker will happily tell you that $\bad$ is terminating.
But $\wh \cl{\bad \infty}{\rho}$ is not defined!
It can be argued that the pattern $(\s i)$ is not \emph{complete}, in a sense that 
a \emph{hypothetical} $\zero$ size element is not matched. 
For the same reason, the following function definition is also not admissible:
\begin{bsp}
$\fun \foo : \EPi{i}{\Size}{\SNat i \ra \Nat}$\\
$\spc \foo \inacc{\s i} \: (\zero \s i = \foo i \: (\zero i)$\\
$\spc \foo \inacc{\s i}\: (\suc i x) = \foo i x; l$
\end{bsp}
This is similar to the \emph{bottom-check} in other work on sized types.

Actually, the type of the above functions was correct.
But in the \mugda program in figure \ref{loop} we have to reject the 
type of the function $\lop$, while all patterns are complete.
So the type 
\begin{bsp}
$\EPi{i}{\Size}{\SNat i \ra \Maybe (\SNat \s i) \ra (\Nat \ra \Maybe (\SNat i))} $ 
\end{bsp}
needs to be rejected by an admissibility checker.
Otherwise, the non terminating term $\diverge$ can be constructed.
\begin{figure}
$\data \Maybe ( + A : \Set ) : \Set$\\
$\spc  \nothing : \Maybe A$\\
$\spc  \just : A \ra\Maybe A$\\

$\clet \Nat : \Set = \SNat \infty$\\

$\fun \shiftcase : (i : \Size) \ra\Maybe (\SNat \s i) \ra\Maybe (\SNat i)$\\
$\spc \shiftcase i \: (\nothing \inacc{\SNat \s i}) = \nothing (\SNat i)$\\
$\spc \shiftcase \inacc{i} \: (\just \inacc{\SNat \s i} \: (\zero i)) = \nothing (\SNat i)$\\
$\spc \shiftcase \inacc{i} \: (\just \inacc{\SNat \s i} \: (\suc i \: x)) = \just (\SNat i) \: x$\\

$\clet \shift : (i : \Size) \ra(\Nat \ra \Maybe (\SNat \s i)) $\\
$\spcx \spcx \ra\Nat \ra \Maybe (\SNat i) $\\ 
$\spc = \lam{i}{\lam{f}{\lam{n}{\shiftcase i \: (f \: (\suc \infty \: n))}}}$\\

$\clet \inc : \Nat \ra \Maybe \Nat = \lam{n}{\just \Nat \: (\suc \infty n)}$\\

$\mutual$\\
$\spc \fun \lop : (i : \Size ) \ra \SNat i $\\
$\spcx \spcx \ra (\Nat \ra\Maybe (\SNat i)) \ra\Bool$\\
$\spc \spc \lop \inacc{\s i} \: (\zero i) f = \lopcase \s i \: (\zero i) \: f \: (f \: (\zero i))$\\
$\spc \spc \lop \inacc{\s i} \: (\suc i \: n) f = \lop i \: n (\shift i \: f)$\\

$\spc \fun \lopcase : (i : \Size ) \ra (\Nat \ra \Maybe (\SNat i)) $\\
$\spcx \spcx \ra \Maybe (\SNat i) \ra\Bool$\\
$\spc \spc \lopcase i \: f \: (\nothing \inacc{\SNat i}) = \ttt $\\
$\spc \spc \lopcase \inacc{\s i} \: f \: (\just \inacc{\SNat \s i} \: (\zero i)) = \ttt $\\
$\spc \spc \lopcase \inacc{\s i} \: f \: (\just \inacc{\SNat \s i} \: (\suc i \: y)) = \lop i \: y \: (\shift i \:f) $\\

$\clet \diverge : \Bool = \lop \infty\: (\zero \infty) \: \inc$\\
\caption{Loop example}
\label{loop}
\end{figure}

\subsection{Admissibility criterion}

\newcommand{\mon}[3]{#1\vdash#2\mbox{ \textbf{mon} }#3}
\newcommand{\indu}[3]{#1\vdash#2\mbox{ \textbf{ind} }#3}
\newcommand{\coind}[3]{#1\vdash#2\mbox{ \textbf{coind} }#3}
\newcommand{\admIndSize}[3]{#1\vdash#2\mbox{ \textbf{admIndSize} }#3}
\newcommand{\admCoSize}[3]{#1\vdash#2\mbox{ \textbf{admCoSize} }#3}
\newcommand{\admIndType}[2]{#1\vdash#2\mbox{ \textbf{admIndType}}}
\newcommand{\admCoType}[2]{#1\vdash#2\mbox{ \textbf{admCoType}}}

\newcommand{\sizePat}[1] {\vdash  #1\mbox{ \textbf{sizePat}}}
\newcommand{\sizePats}[1]{\vdash #1\mbox{ \textbf{sizePats}}}

\section{Admissible inductive function declaration}

\begin{figure}
\begin{gather*}
\nru{}
{\LeqVal{k}{\nF}{v}{\subst{(i,\s i)}{v}}}
{\mon{k}{v}{i}}
\qquad
\nru{}
{\DD \mbox{ sized data}}
{\indu{k}{\DD p_1 \ldots p_n \: i \: v_1 \ldots v_m}{i}}
\\[2ex]
\ndru{}
{\indu{k}{v_a}{i} \quad \mbox{or} \quad \nocc{k}{v_a}{i}}
{\admIndSize{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{i}}
{\admIndSize{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}{i}}
\nru{}
{}
{\admIndSize{k}{v}{i}}
\\[2ex]
\ndru{}
{\admIndSize{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{k} \mbox{ if } v_a = \Size}
{\admIndType{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\admIndType{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}}
\qquad
\nru{}
{}
{\admIndType{k}{v}}
\end{gather*}
\caption{Admissibility for inductive function type}
\end{figure}

For consistency, it is necessary to check that the clauses of a definition cover all possible cases.
This is quite complicated for inductive families and will not be described here.

But as special case is pattern completeness for the built-in $\Size$ type.
As we have seen, without this check we would even accept non-terminating function definitions.
This is like the \emph{bottom-check} in the work of Pareto and Sabry.

\subsubsection{Size pattern completeness}
For an mutual inductive declaration $\delta$, the patterns $\vec{p}$ are complete 
if no pattern of the form $(\s p)$ occurs. 
Note that this still allows $\s$ to appear inside of inaccessible patterns.
We do not need to check co-inductive declarations because, in a way, the size argument is kind of
inaccessible: it is actually determined by the right hand side - the object that is being defined. 

We finally arrive at
\subsubsection{Admissible inductive definition}
the mutual inductive function declaration
\begin{bsp}
$\mutual$\\
$\spcx \fun f_1 : t_1 $\\
$\spcx \spc \vec{\gamma}_1$\\
$\spcx \ldots$\\
$\spcx \fun f_n : t_n $\\
$\spcx \spc \vec{\gamma}_n$
\end{bsp}
is \emph{admissible}, if  for every $i \in \{1 \ldots n \}  $
\begin{enumerate}
\item
$\admIndType{1}{\wh \cl{t_i}{\diamond}}$
\item
$\sizePats{\vec{p}}$ for every clause $(f \vec{p} e) \in \gamma_i$
\end{enumerate}

\subsubsection{Example}
For the rejected example $\lop$, $i$ is occurring in the argument \[\Maybe (\SNat \s i)\], but is not inductive in $i$, which renders the functions $\lop$ (and also $ \shiftcase$ and $\lopcase$) non-admissible.



\subsubsection{Admissible co-inductive declarations}
For co-inductive functions, the type admissibility criterion is even more restrict.
A size can only be used \emph{co-inductive} in the result.
This implies that only one size argument can be used.

\subsubsection{Admissibility criterion}
the mutual co-inductive function declaration
\begin{bsp}
$\mutual$\\
$\spcx \cofun f_1 : t_1 $\\
$\spcx \spc \vec{\gamma}_1$\\
$\spcx \ldots$\\
$\spcx \cofun f_n : t_n $\\
$\spcx \spc \vec{\gamma}_n$
\end{bsp}
is \emph{admissible}, if  for every $i \in \{1 \ldots n \}  $
\begin{enumerate}
\item
$\admCoType{1}{\wh \cl{t_i}{\diamond}}$
\end{enumerate}

\begin{figure}
\begin{gather*}
\nru{}
{\DD \mbox{ sized co-data}}
{\coind{k}{\DD p_1 \ldots p_n \: i \: v_1 \ldots v_m}{i}}
\\[2ex]
\nru{}
{\nocc{k}{v_a}{i}
\quad
\admCoSize{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{i}}
{\admCoSize{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}{i}}
\quad
\nru{}
{}
{\admCoSize{k}{v}{i}}
\\[2ex]
\ndru{}
{\admCoSize{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}{k} \mbox{ if } v_a = \Size}
{\admCoType{k+1}{\wh \cl{b}{\ins{\rho}{x}{k}}}}
{\admCoType{k}{\vpi \: x \: v_a \: \cl{b}{\rho}}}
\qquad
\nru{}
{}
{\admCoType{k}{v}}
\end{gather*}
\caption{Admissibility for co-inductive function type}
\end{figure}

Both admissibility criteria do not allow an argument of the form $\Stream i$.
Functions an only have arguments of the form $\Stream \infty$, so pattern matching can only 
happen on fully constructed co-inductive objects.

\subsection{On the necessity of sub-typing}
Sub-typing for inductive types is actually not a necessity 
For example
\begin{bsp}
$\fun \wkSNat : (i : \Size ) \ra \SNat i \ra \SNat \s i$\\
$\spc \wkSNat \inacc{\s i} \: (\zero i) = \zero \s i$\\
$\spc \wkSNat \inacc{\s i} \: (\suc i \: x) = \suc \s i \: (\wkSNat i \: x) $
\end{bsp}
could be used to weaken an object into a greater type.
But sub-typing does make the system more comfortable, plus this weakening would have
a significant impact on run-time performance.
Its bad brother 
\begin{bsp}
$\fun \wkSNatb : (i : \Size ) \ra \SNat (\s i) \ra \SNat i$\\
$\spc \wkSNatb \inacc{\s i} \: (\zero (\s i) = \zero i$\\
$\spc \wkSNatb \inacc{\s i} \: (\suc (\s i) \: x) = \suc i \: (\wkSNatb i \: x) $
\end{bsp}
fails to pass the admissibility test. 
For streams as a co-inductive type, the weakening function would be
\begin{bsp}
$\cofun \wkStream : ( A : \Set ) \ra (i : \Size ) \ra Stream A \s i \ra Stream A i$\\
$\wkStream \inacc{A} \: \inacc{\s i} \: (cons A \: (\s i) \: x \: xs) = \cons A \: i \: x \: (\wkStream A \: i \: xs) $
\end{bsp}
but this does not pass the admissibility check, as we do not want to allow pattern matching against 
partially constructed co-inductive objects. 
This seems to indicate that a less restrict admissibility criterion should be achievable.


\section{Putting it all together}


\subsubsection{Proposition : Size change principle for Mugda with sized types}
Given
\begin{enumerate}
\item
$\Sigma$ a terminating signature
\item
a mutual inductive (co-inductive) declaration $\delta$
\item
$\Sigma'$ resulting from type-checking $\delta$ in $\Sigma$
\item
$\delta$ is admissible
\end{enumerate}
then $\Sigma'$ is terminating and $\delta$ is terminating (resp. productive for a co-inductive declaration), if every idempotent call-matrix $ M \in \complete \cg(\delta)$ has a decreasing element in the diagonal.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "da"
%%% End: 
