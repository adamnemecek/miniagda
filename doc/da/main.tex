\chapter{Basic MiniAgda}

% Inference rules
\newcommand{\rulename}[1]{\ensuremath{\mbox{\sc#1}}}
\newcommand{\ru}{\dfrac}
\newcommand{\rux}[3]{\ru{#1}{#2}\ #3}
\newcommand{\nru}[3]{#1\ \ru{#2}{#3}}
\newcommand{\nrux}[4]{#1\ \ru{#2}{#3}\ #4}
\newcommand{\dstack}[2]{\begin{array}[b]{c}#1\\#2\end{array}}
\newcommand{\xstack}[3]{\begin{array}[b]{c}#1\\#2\\#3\end{array}}
\newcommand{\ndru}[4]{#1\ \ru{\dstack{#2}{#3}}{#4}}
\newcommand{\nxru}[5]{#1\ \ru{\xstack{#2}{#3}{#4}}{#5}}
\newcommand{\ndrux}[5]{#1\ \ru{\dstack{#2}{#3}}{#4}\ #5}


% rule names

\newcommand{\infvar}{\rulename{inf-var}}
\newcommand{\infset}{\rulename{inf-set}}
\newcommand{\infsize}{\rulename{inf-size}}
\newcommand{\infinfty}{\rulename{inf-infty}}
\newcommand{\infappa}{\rulename{inf-app-i}}
\newcommand{\infappb}{\rulename{inf-app-ii}}
\newcommand{\infcon}{\rulename{inf-con}}
\newcommand{\infdef}{\rulename{inf-def}}
\newcommand{\infconst}{\rulename{inf-const}}

\newcommand{\chklam}{\rulename{chk-lam}}
\newcommand{\chkpi}{\rulename{chk-pi}}
\newcommand{\chksucc}{\rulename{chk-succ}}
\newcommand{\chkinf}{\rulename{chk-inf}}

\newcommand{\eqnf}{\rulename{eq-nf}}
\newcommand{\eqlf}{\rulename{eq-lf}}
\newcommand{\eqrf}{\rulename{eq-rf}}

\newcommand{\eqset}{\rulename{eq-set}}
\newcommand{\eqsize}{\rulename{eq-size}}
\newcommand{\eqsuc}{\rulename{eq-succ}}
\newcommand{\eqinfty}{\rulename{eq-infty}}
\newcommand{\eqapp}{\rulename{eq-app}}
\newcommand{\eqgen}{\rulename{eq-gen}}
\newcommand{\eqpi}{\rulename{eq-pi}}
\newcommand{\eqlam}{\rulename{eq-lam}}
\newcommand{\eqdef}{\rulename{eq-def}}
\newcommand{\eqcon}{\rulename{eq-con}}

\newcommand{\chkpvar}{\rulename{chkp-var}}
\newcommand{\chkpcon}{\rulename{chkp-con}}
\newcommand{\chkpsucc}{\rulename{chkp-succ}}
\newcommand{\chkpinacc}{\rulename{chkp-inacc}}

\newcommand{\leqnf}{\rulename{leq-nf}}
\newcommand{\leqlf}{\rulename{leq-lf}}
\newcommand{\leqrf}{\rulename{leq-rf}}

\newcommand{\leqset}{\rulename{leq-set}}
\newcommand{\leqsize}{\rulename{leq-size}}
\newcommand{\leqsuc}{\rulename{leq-succ}}
\newcommand{\leqinfty}{\rulename{leq-infty}}
\newcommand{\leqappco}{\rulename{leq-co}}
\newcommand{\leqappind}{\rulename{leq-ind}}
\newcommand{\leqappd}{\rulename{leq-data}}
\newcommand{\leqapp}{\rulename{leq-app}}
\newcommand{\leqgen}{\rulename{leq-gen}}
\newcommand{\leqpi}{\rulename{leq-pi}}
\newcommand{\leqlam}{\rulename{leq-lam}}
\newcommand{\leqdef}{\rulename{leq-def}}
\newcommand{\leqcon}{\rulename{leq-con}}

\newcommand{\sleqinfty}{\rulename{sleq-infty}}

\newcommand{\sleqsucci}{\rulename{sleq-succ-i}}
\newcommand{\sleqsuccii}{\rulename{sleq-succ-ii}}
\newcommand{\sleqgen}{\rulename{sleq-gen}}

\newcommand{\dd}{\mathsf{d}}
\newcommand{\DD}{\mathsf{D}}
\newcommand{\cc}{\mathsf{c}}
\newcommand{\ff}{\mathsf{f}}

\newcommand{\cll}{\mathbb{L}}
\newcommand{\cdd}{\mathbb{D}}
\newcommand{\ccc}{\mathbb{C}}
\newcommand{\cff}{\mathbb{F}}
\newcommand{\cV}{\mathbb{V}}

\newcommand{\cS}{\mathbb{S}}
\newcommand{\cN}{\mathbb{N}}
\newcommand{\cI}{\mathbb{I}}
\newcommand{\cF}{\mathbb{F}}
\newcommand{\nF}{\mathbf{N}}
\newcommand{\lF}{\mathbf{L}}
\newcommand{\rF}{\mathbf{R}}

\newcommand{\sz}{\mathbf{sz}}
\newcommand{\ns}{\mathbf{nosz}}
\newcommand{\co}{\mathbf{co}}
\newcommand{\ind}{\mathbf{ind}}

\newcommand{\Expr}{\mathrm{Expr}}
\newcommand{\Val}{\mathrm{Val}}
\newcommand{\vlam}{\mathrm{Lam}}
\newcommand{\vpi}{\mathrm{Pi}}
\newcommand{\Clos}{\mathrm{Clos}}
\newcommand{\cl}[2]{#1^{#2}}
\newcommand{\clp}[2]{\cl{(#1)}{#2}}
\newcommand{\Env}{\mathrm{Env}}
\newcommand{\wh}{\searrow}
\newcommand{\ap}{\mathrm{app}}
\newcommand{\apf}{\mathrm{appFun}}
\newcommand{\sinfty}{\mathrm{sinfty}}
\newcommand{\lkup}{\mathrm{lkup}}
\newcommand{\ins}{\mathrm{ins}}
\newcommand{\forc}{\mathrm{force}}
\newcommand{\matchcls}{\mathrm{matchcls}}
\newcommand{\matchcl}{\mathrm{matchcl}}
\newcommand{\match}{\mathrm{match}}
\newcommand{\matchf}{\mathrm{match'}}
\newcommand{\matchList}{\mathrm{matchList}}
\newcommand{\matchInfty}{\mathrm{matchInfty}}
\newcommand{\stuck}{\;\Uparrow}
\newcommand{\Clause}{\mathrm{Clause}}
\newcommand{\Decl}{\mathrm{Decl}}
\newcommand{\Pat}{\mathrm{Pat}}

\newcommand{\Sig}{\mathrm{\Sigma}}

\begin{figure}[p]
\caption{MiniAgda syntax}
Expressions : \[e,t :  \lam x . e \mid \EPi{x}{t}{t} \mid e \; \vec{e} \mid  \Set \mid x \mid \cc \mid \DD \mid \ff \mid \dd\]
Patterns: \[ x  \mid \cc \; \vec{p} \]
\end{figure}

MiniAgda is a small experimental version of Agda.
The current version of Agda is described by Ulf Norell in his thesis \cite{norell:thesis}.



\section{Syntax}
First, let us denote the following sets:
\begin{itemize}
\item
$ \cN $ for natural numbers
\item
$ \cI = \{ \ind , \co \} $ of induction kinds to distinguish wether a function or data type is 
inductive or coinductive  
\item
$ \cS = \{ \sz, \ns \} $ of size kinds to distinguish wether a data type is sized or not
\end{itemize}

Let $\vec{a} \in \ves{A} $ denote a (possible empty) list of elements of a set $A$
and $\diamond$ denote the empty list. $\#\vec{a}$ denotes the size of vector $\vec{a}$.

First we assume the following disjunct sets of identifiers.
\[
\begin{array}{ll}
\ccc \ni \cc & \mbox{for constructors}\\
\cdd \ni \DD & \mbox{for data types}\\
\cff \ni \ff & \mbox{for functions}\\
\cll \ni \dd & \mbox{for constants}\\
\cV \ni x,y,i & \mbox{vor variables}
\end{array}
\]

\paragraph*{Expressions}
\[
\begin{array}{lrll}
\Expr \ni e,A,B & ::= & \lam{x}{e} & \mbox{abstraction}\\
& \mid & \EPi{x}{A}{B} & \mbox{dep function type}\\
& \mid & e \; \vec{e} & \mbox{application}\\
& \mid & \Set & \mbox{type of types}\\
& \mid & \Size & \mbox{size type} \\
& \mid & \s e  & \mbox{size succesor}\\ 
& \mid & \infty & \mbox{limit size}\\
& \mid & x & \mbox{variable}\\
& \mid & \cc & \mbox{constructor}\\
& \mid & \DD & \mbox{data type}\\
& \mid & \ff & \mbox{function}\\
& \mid & \dd & \mbox{const}
\end{array}
\]

\paragraph*{Patterns}
\[
\begin{array}{lrll}
\Pat \ni p & ::= & x & \mbox{variable pattern}\\
& \mid & \cc \; \vec{p} & \mbox{constructor pattern}\\
& \mid & \s p & \mbox{size succesor pattern}\\
& \mid & \inacc{e} & \mbox{inaccessible pattern}\\
\end{array}
\]

\paragraph*{Constructor definitions}
\[
\begin{array}{lrll}
\gamma &  ::= & \cc \; : \; A & 
\end{array}
\]

\paragraph*{Clause definitions}
\[
\begin{array}{lrll}
\Clause \ni \kappa & ::= & \ff \; \vec{p} = e & 
\end{array}
\]

\paragraph*{Data Telescopes}
\[
\begin{array}{lrll}
\tau & ::= & \diamond & \mbox{empty telescope}\\
& \mid & ( x : t ) \; \tau & \mbox{parameter}\\
& \mid & ( + \; x : t ) \; \tau & \mbox{strictly positive paramter}
\end{array}
\]

\paragraph*{Declarations}
\[
\begin{array}{lrll}
\Decl \ni \delta & ::= & \data \DD \tau : A \vec{\gamma} & \mbox{inductive datatype}\\ 
& \mid & \codata \DD \tau : A \vec{\gamma} & \mbox{coinductive data type} \\
& \mid & \fun \ff : A \; \vec{\kappa} & \mbox{recursive function}\\
& \mid & \norec \ff : A \; \vec{\kappa} & \mbox{nonrecursive function}\\
& \mid & \cofun \ff : A \; \vec{\kappa} & \mbox{corecursive function}\\ 
& \mid & \const \dd : A \; = e & \mbox{constant}\\
& \mid & \mutual \vec{\delta} & \mbox{mutual declaration}
\end{array}
\]
A MiniAgda program $\vec{\delta}$ is a list of declarations.
We assume a MiniAgda program is correctly scoped, i.e every identifier
is only declared once and only used after declaration and variables are bound by lambda or variable patterns.
For $\mutual$ declarations, we only allow either multiple $\fun$ or $\cofun$ declarations.
Each declaration adds newly defined constructs to the signature $\Sig$.
The signature is empty at the beginning.
\subsection{Semantic}
We simultanously define closures, values, environments and signatures.

\paragraph*{Closures}
\[
\begin{array}{lrll}
\Clos \ni c & ::= & \cl{e}{\rho} & 
\end{array}
\]

\paragraph*{Values}
\[
\begin{array}{lrll}
\Val \ni v & ::= & v \; \vec{c} & \mbox{lazy application}\\
& \mid & \vlam \; x \; \rho & \mbox{abstraction closure}\\
& \mid & \vpi \; x \; v \rho & \mbox{dependent function type closure}\\
& \mid & k & \mbox{generic variables}\\
& \mid & \Set & \mbox{type of types} \\
& \mid & \Size & \mbox{size type value}\\
& \mid & \s v & \mbox{size succesor}\\
& \mid & \infty & \mbox{size limit}\\
& \mid & \cc & \mbox{constructor}\\
& \mid & \ff & \mbox{function symbol}\\
\end{array}
\]
The generic variables $k \in \cN $ are used as fresh variables during type checking.
Environments
\paragraph*{Environments}
\[
\begin{array}{lrll}
\Env \ni \rho & ::= & \diamond & \mbox{empty environment}\\
& \mid & (x,v) \rho & \mbox{extension with value}\\
& \mid & (x,c) \rho & \mbox{environment wih closure} 
\end{array}
\]

\paragraph*{Signatures}
The signature carries information about the user-defined constants
We define it as a overloaded function:
\begin{itemize}
\item
$ \Sig : \cff \ra \cI \times \Val \times \ves{\Clause}$\\
recording for a function symbol the recursion kind, the type and the defining clauses.
\item
$ \Sig : \cll \ra \Expr \times \Val $ \\
recording for a const definition the expression and its type. 
\item
$ \Sig : \ccc \ra \Val $
recording for a constructor its type.
\item
$ \Sig : \cdd \ra \cN \times \ves{\cN} \times \cS \times \cI \times \Val $\\
recording for a data type the number of parameters, the indices of the strictly positive arguments,
the size kind, the induction kinds and its type.
\end{itemize}
Now we define evaluation. A fixed signature $\Sig$ is assumed.
\paragraph*{weak-head evaluation}


\[
\begin{array}{ll}
\multicolumn{2}{l}{\wh \; : \Clos \ra \Val}\\
\wh \clp{\lam{x}{e}}{\rho} & = \vlam \; x \; \cl{e}{\rho} \\
\wh \clp{\EPi{x}{a}{b}}{\rho} &= \vpi \; x \; v_a \; \cl{b}{\rho} \mbox{ where } v_a = \wh \cl{a}{\rho} \\
\wh \clp{e \; e_1 \ldots e_n}{\rho} &= \ap \; v \; v_1 \ldots v_n \mbox{ where } v_i = \wh \cl{(e_i)}{\rho} \\
\wh \cl{\Set}{\rho} & = \Set \\ 
\wh \cl{\Size}{\rho} & = \Size \\
\wh \cl{\infty}{\rho} & = \infty  \\
\wh \clp{\s e}{\rho} & = \sinfty \; v \mbox{ where } \; v = \wh \cl{e}{\rho} \\ 
\wh \cl{\cc}{\rho} & = \cc  \\
\wh \cl{\ff}{\rho} & = \ff \\
\wh \cl{\dd}{\rho} & = \wh \cl{e}{\diamond} \mbox{ where } \; \Sig \; \dd = (e,\_)\\
\wh \cl{x}{\rho} & = \lkup \; \rho \; x \\
\end{array}
\]

\paragraph*{size succesor}

\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\sinfty : \Val \ra \Val}\\ 
\sinfty \; \infty & = \infty\\
\sinfty \;  x & = \s x  \mbox{ otherwise}\\ 
\end{array}
\]
\paragraph*{application}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\ap : \Val \ra \ves{\Clos} \ra \Val}\\
\ap \; u \; \diamond & = u \\
\ap \; (u \; \vec{c_1}) \; \vec{c_2} & = \ap \; u (\vec{c_1}\;\vec{c_2})\\
\ap \; (\vlam \; x \; \cl{e}{\rho}) \; (c \vec{c}) & = \ap \; v \; \vec{c} \mbox{ where } v = \wh \cl{e}{\ins \; \rho \; (x,c)} \\ 
\ap \; \ff \; \vec{c} & = \apf \; \ff \; \vec{c} \mbox{ if } \Sig \; \ff = (\ind,\_) \\
\ap \; v \; \vec{c} & = v \; \vec{c} \mbox{ otherwise } \\
\end{array}
\]

\paragraph*{Environment insert}  
\[
\begin{array}{ll}
\multicolumn{2}{l}{\ins : \Env \ra \cV \ra ( \Val \cup \Clos ) \ra \Env}\\
\ins \; \rho \; x \; y & = (x,y) \rho
\end{array}
\]

\paragraph*{Environment lookup}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\lkup : \Env \ra \cV \ra \Val }\\
\lkup \; ((x,v) \rho) \; x & = v \mbox{ if } v \mbox{ is a value} \\
\lkup \; ((x,c) \rho) \; x & = \wh c \mbox{ if } c \mbox{ is a closure} \\
\lkup \; ((y,z) \rho) \; x & = \lkup \; \rho \mbox{ if } y \neq x  
\end{array}
\]

\paragraph*{Inductive funcion matching}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\apf : \cV \ra \ves{\Clos} \ra \Val}\\
\apf \; \ff \; \vec{c} & = \matchcls \; \vec{l} \vec{c} \mbox{ if } \Sig \; \ff = (\ind,\_,\vec{l}) 
\end{array}
\]

\paragraph*{Corecursive unrolling}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\forc : \Val \ra \Val }\\
\forc \; \ff & = \matchcls \vec{l} \diamond \mbox{ if } \Sig \; \ff = (\co,\_,\vec{l})  \\
\forc \; \ff \; \vec{c} & = \matchcls \vec{l} \vec{c} \mbox{ if } \Sig \; \ff = (\co,\_,\vec{l})\\ 
\forc \; v & = \stuck \mbox{ otherwise}
\end{array}
\]

\paragraph*{clauses matching}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchcls : \ves{\Clause} \ra \ves{\Clos} \ra \Val}\\
\matchcls \; \_ \; \diamond & = \stuck \\
\matchcls \;  ((\vec{p} \; e)\;\vec{l}) \vec{c} & = v \mbox{ if } v = \matchcl \; \diamond \; \vec{p} \; e \;  \vec{c} \\
\matchcls \; ((\vec{p} \; e)\;\vec{l}) \vec{c} & = \matchcls \vec{l} \vec{c} \mbox{ otherwise}  
\end{array}
\]

\paragraph*{clause matching}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchcl : \ves{\Clause} \ra \ves{\Pat} \ra \Expr \ra \ves{\Clos} \ra \Val}\\
\matchcl \; \rho \; \diamond \; e \; \vec{c} & = \ap \; v_1 \; \vec{c} \mbox{ where } v = \wh e \; \rho \\
\matchcl \; \_ \; \_\; \_ \; \diamond & = \stuck \\
\matchcl \; \rho \; (p \; \vec{p}) \; e \; (c \; \vec{c}) & = \matchcl \; \rho_2 \; \vec{p} \; vec{c} \mbox{ if } \rho_2 = \match \; p (\wh c)   
\end{array}
\]

\paragraph*{pattern matching}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\match : \Env \ra \Pat \ra \Val \ra \Env}\\
\match \; \rho \; p \; v & = \matchf \; \rho \; p \; v' \\
& \mbox{ if } p = \cc \vec{p} \mbox{ where } \cc  \mbox{ is a coinductive constructor}\\
& \mbox{ where } v' = \forc v \\
\match \; \rho \; p \; v & = \matchf \; \rho \; p \; v \mbox{ otherwise}\\
\multicolumn{2}{l}{\matchf : \Env \ra \Pat \ra \Val \ra \Env}\\
\matchf \; \rho \; \inacc{e} \; v & = \rho \\
\matchf \; \rho \; x \; v & = (x,v)\; \rho \\
\matchf \; \rho \; (\cc \diamond) \; (\cc) & = \rho \\
\matchf \; \rho \; (\cc \vec{p}) (\cc \vec{v}) & = \matchList \; \rho \; \vec{p} \; \vec{v} \\
\matchf \; \rho \; p \; \infty & = \matchInfty \, \rho \; p \\
\matchf \; \rho \; (\s p) \; (\s v) & = \match \rho \rho \; p \; v \\
\matchf \; \_ \; \_ \; \_ & = \stuck \mbox{ otherwise}
\end{array}
\]

\paragraph*{pattern matching against infty}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchInfty : \Env \ra \Pat \ra \Env}\\
\matchInfty \; \rho \; \inacc{e} & = \rho\\
\matchInfty \; \rho \; x & = (x,\infty)\; \rho \\
\matchInfty \; \rho \; (\s p)  & = \matchInfty \; \rho \; p \\
\matchInfty \; \_ \; \_ \; \_ & = \stuck \mbox{ otherwise}
\end{array}
\]
\paragraph*{pattern matching list}
\[
\begin{array}{ll}
\multicolumn{2}{l}{\matchList : \Env \ra \ves{\Pat} \ra \ves{\Clos} \ra \Env }\\
\matchList \; \rho \; \diamond \; \diamond & = \rho \\
\matchList \; \rho \; (p \; vec{p}) \; (c \; vec{c} & = \matchList \rho_2 \vec{p} \vec{v} \mbox{ where } \rho_2 \; = matchList \; \rho \; p \; v \\
\end{array}
\]

\section{Examples}
\subsection{Identity function}
Without defining new data types, we still can define some useful non recursive functions.
One example is the polymorphic identity function. 
MiniAgda is monomorphic, so this is not really a polymorphic function, as you have to supply the
type as the first argument.
\begin{bsp}
$\const id : \EPi{A}{\Set}{A \ra A} = \lam{a}\lam{x}x$   
\end{bsp}
We simple add the definition of $id$ to the signature:
\begin{bsp}
$\Sig := \{ id : \EPi{A}{\Set}{A \ra A} = \lam{a}\lam{x}x$
\end{bsp}
\subsection{Booleans}
The booleans are an example of a non-inductive enumeration type.
\begin{bsp}
$\data \Bool : \Set$  \\
$\spc \ttt : \Bool $\\
$\spc \fff : \Bool $
\end{bsp}
Three new constants are added to the signature
\[ \Sig := \{ \Bool : \Set , \ttt : \Bool , \fff : \Bool \} \]
\subsection{Natural Numbers}
First we declare the type of natural numbers:
\begin{bsp}
$\data \Nat : \Set$ \\
$\spc \zero : \Nat $\\
$\spc \suc : \Nat \ra \Nat$
\end{bsp}
then we declare the addition function by pattern matching:
\begin{bsp}
$\fun \add : \Nat \ra \Nat \ra \Nat$\\
$\spc \add x \; \zero = x $\\
$\spc \add x \; (\suc y) = \suc (\add x \; y)  $
\end{bsp}
\subsection{Lists}
Lists are an example of a parameterized data type:
\begin{bsp}
$\data \List ( A : \Set ) : \Set $ \\
$ \spc \nil : \List A  $\\
$ \spc \cons : A \ra \List A \ra \List A $
\end{bsp}
\subsection{Binary Trees}
The following introduces binary trees with leaf labeled with elements of $A$ and nodes labeled with elements of $B$:
\begin{bsp}
$\data \Tree ( A : \Set ) ( B : \Set ) : \Set $ \\
$ \spc \leaf : A \ra \Tree A \; B $\\
$ \spc \node : B \ra \Tree A \; B \ra \Tree A \; B $
\end{bsp}
The tree definition adds the following constants to the signature:
\begin{bsp}
$\Tree  : ( A : \Set ) \ra ( B : \Set ) \ra \Set$ \\
$ \spc \leaf : ( A : \Set ) \ra ( B : \Set ) \ra A \ra \Tree A \; B $ \\
$ \spc \node : ( A : \Set ) \ra ( B : \Set ) \ra A B \ra \Tree A \; B $
\end{bsp}
\section{Vectors}
The previous data types didn't use any dependent function space. 
Now things get more interesting. Vectors are an example of an inductive family of types.
They can be imagined as lists that store their length.
\begin{bsp}
$\data \vVec ( A : \Set ) : \Nat \ra \Set $ \\
$\spc \nil : \vVec A \; \zero  $\\
$ \spc \cons : \EPi{n}{\Nat}{ A \ra \vVec A \; n \ra \vVec A \; (\suc n)} $
\end{bsp}
Now let's define the $\head$ function that returns the first element of an vector. This operation should only be allowed for a non-empty vector.
With dependent types, we can express this in the type signature
\begin{bsp}
$ \fun \head : ( A : \Set ) \ra ( n : \Nat ) \ra \vVec A \; (\suc n) \ra A $
\end{bsp}
Now to the clause definition. We can explain the use inaccessible patterns here.
We need to pattern match to get the head element.
\begin{bsp}
$\head ? \; ? \; (\cons \; B \; m \; x \; xl) = x $
\end{bsp}
First, let's note that we don't need to pattern match against $\nil$.
Now what about the ? above. 
One might be inclined to use non-linear patterns:
\begin{bsp}
$\head \; B \; m \; (\cons  B \; m \; x \; xl) = x $
\end{bsp}
But we really don't have to check at runtime that the values at the corresponding arguments match -- it's guaranteed for a well-typed program.
So to really capture the notion that the first two arguments are automatically instantiated by pattern matching against the inductive family argument, we use the inaccessible pattern notation. The final definition is:
\begin{bsp}
$ \fun \head : ( A : \Set ) \ra ( n : \Nat ) \ra \vVec A \; (\suc n) \ra A $\\
$ \spc \head \inacc{B} \; \inacc{m} \; (\cons \; B \; m \; x \; xl) = x $
\end{bsp}
\subsection{Equality}
The following is called Martin-L\"of equality.
The equality relation is defined by reflexivity.
\begin{bsp}
$\data \Eq ( A : \Set ) : A \ra A \ra \Set $ \\
$\spc \refl : A \ra \Eq A \; A  $
\end{bsp}
As a simple example, we can now prove that $ 0 + x = x $.
\begin{bsp}
$ \const \prof : \EPi{x}{\Nat}{\Eq \Nat (\add \zero x) x} $ \\ 
$ \spcx = \lam{y}\refl \Nat y$ 
\end{bsp}
Here we see that proof checking equals type checking.
Now if we want to prove $ x + 0 = x $, we need more effort.
The following does not pass the type checker
\begin{bsp}
$ \const \prof2 : \EPi{x}{\Nat}{\Eq \Nat (\add x \; \zero)  x} $ \\ 
$ \spcx \lam{y} \refl \Nat y$ 
\end{bsp}
The reason why is that type checker can only see definitional equality.
Note that addition was defined by recursion on the second argument. 
What we need is a recursive proof.

\begin{bsp}
$\fun \eqsucc : \EPi{x}{\Nat}\EPi{y}{\Nat} \Eq \Nat x \; y \ra \Eq \Nat (\suc x) \; (\suc y)$ \\
$\spc \eqsucc \inacc{x} \; \inacc{x} \; (\refl \inacc{\Nat} \; x) = \refl \Nat (\suc x)$\\
$\fun \tprof : ( x : \Nat ) \ra \Eq \Nat (\add \zero x) x$\\
$\spc \tprof \zero = \refl \Nat \zero$\\
$\spc \tprof (\suc x) = \eqsucc (\add \zero x)\; x \; (\tprof x)$
\end{bsp}

Recursive proofs need to be total (complete pattern matching and termination) to be correct.

\section{Universes}
To keep MiniAgda simple, $\Set$ is the type of all types.
This is known to be inconsistent.
It is quite complicated but possible to define a recursor.
Universe stratication can be used to avoid this inconsistency.

\section{Missing features}
Due to its use for interactivly building proofs, the full Agda has meta-variables that represent parts of tge proof that are still misssing. These 
Also, many bookkeeping arguments can be easily infered by the type checker,easying tedious pain for the user.
The user can mark these arguments as \emph{implicit}. The type checker will automatically infer them.
To keep MiniAgda simple, these features were not implemented.

\section{Type Checking}

\renewcommand\Check[5]{#1,#2,#3\vdash#4\leftleftarrows#5}
\newcommand\IsType[4]{\Check{#1}{#2}{#3}{#4}{\Set}}
\newcommand\Infer[5]{#1,#2,#3\vdash#4\rightrightarrows#5}
\newcommand\EqVal[4]{#1,#2\vdash#3\Leftrightarrow#4}
\newcommand\FeqVal[4]{#1,#2\vdash#3{\;\leftrightarrow\;}#4}
\newcommand\DeqVal[2]{\vdash#1\leftrightarrow#2}
\newcommand\LeqVal[4]{#1,#2,\vdash#3\leq#4}
\newcommand\FleqVal[4]{#1,#2\vdash#3{\;\ll\;}#4}
\newcommand\DLeqVal[2]{\vdash#1\leq#2}
\newcommand\SzLeq[2]{\vdash#1\sqsubseteq#2}

\subsection{Bidirectional type checking} 
For depentend types, a practice called \emph{bidirectional type checking} is used.
This means that the type checker has two modes:
one for checking that an expression has a certain type and one for infering the type of an expression.

\begin{description}
\item[check expression]:
\[\Check{k}{\rho_1}{\rho_2}{e}{v} \subseteq \cN \times \Env \times \Env \times \Expr \times \Val\]
\item[infer expression]:
\[\Infer{k}{\rho_1}{\rho_2}{e}{v} : \cN \times \Env \times \Env \times \Expr \ra \Val\]
\item[is type]:
\[\IsType{k}{\rho_1}{\rho_2}{e} \subseteq \cN \times \Env \times \Env \times \Expr\]
\end{description}

The environment $\rho_1$ will be used to bind fresh generic values to variables, and $\rho_2$ will have the type correspoding to this variables. in checking mode, the type checker might have to infer the type of the expression and then verify that the infered value is equal to the one to be checked against.
So one needs equality between two values.
We want to strengthen equality of coinducive values by allowing the type checker to unroll ($\forc$) a corecusive definition. We cannot allow unlimit unfolding, thus we keep track of unfolding and only allow one of the values to be unrolled.
We introduce the set $ \cF = \{\lF, \rF, \nF \} $ to keep track if we have unrolled the left or right value or not at all.
Thus we introduce simulataneously two judgements, the latter one operating on already unrolled values.
\[\EqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times \Val \times \Val \]
\[\FeqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times\Val \times \Val \]

\begin{figure}[p]

\begin{gather*}
%%Lam
\nru{\chklam}
{\Check{k+1}{\ins \; \rho_1 \; (x,k)}{\ins \; \rho_2 \; (x,v_a)}{e}{\wh (t \; \ins \rho (x,k))}}
{\Check{k}{\rho_1}{\rho_2}{\lam{x}{e}}{\vpi \; x \; v_a \; \cl{t}{\rho}}}
%% Pi
\\[2ex]
\nru{\chkpi}
{\IsType{k}{\rho_1}{\rho_2}{t_1}
\qquad
\IsType{k+1}{\ins \; \rho_1 \; (x,k)} {\ins \; \rho_2 \; (x,\cl{(t_1)}{\rho})}{t2}
}
{\Check{k}{\rho_1}{\rho_2}{\EPi{x}{t_1}{t_2}}{\Set}}
\\[2ex]
%% Succ
\nru{\chksucc}
{\Check{k}{\rho_1}{\rho_2}{\s e}{\Size}} 
{\Check{k}{\rho_1}{\rho_2}{e}{\Size}}
%% Inf
\qquad
\nru{\chkinf}
{\Infer{k}{\rho_1}{\rho_2}{e}{v_2}
\qquad
\EqVal{\nF}{k}{v_2}{v_1}} 
{\Check{k}{\rho_1}{\rho_2}{e}{v_1}}
\end{gather*}
\caption{Checking expressions}
\end{figure}

\begin{figure}[p]
\begin{gather*}
%% Var
	  \nru{\infvar}{\lkup \; \rho_2 \; x \; v}{\Infer{k}{\rho_1}{\rho_2}{x}{v}}
%% Set
\qquad	  \nru{\infset}{} {\Infer{k}{\rho_1}{\rho_2}{\Set}{\Set}}   
\\[2ex]
%% Size
	  \nru{\infsize}{}{\Infer{k}{\rho_1}{\rho_2}{\Size}{\Set}}
\qquad
%% Infty
	  \nru{\infinfty}{}{\Infer{k}{\rho_1}{\rho_2}{\infty}{\Size}} 
\\[2ex]
%% App-1
\nru{\infappa}
{\Infer{k}{\rho_1}{\rho_2}{e_1}{\vpi \; x \; v_a \; \cl{b}{\rho}}
\qquad \Check{k}{\rho_1}{\rho_2}
{e_2}{v_a}}
{\Infer{k}{\rho_1}{\rho_2}{e_1 \; e_2}{\wh b \; (\ins \; \rho \; \cl{{e_2}}{\rho_1})}}
%% App-2
\\[2ex]
\nru{\infappb}
{\Infer{k}{\rho_1}{\rho_2}{(e_1 \; e_2)\;\vec{e}}{v}}
{\Infer{k}{\rho_1}{\rho_2}{e_1 \; (e_2 \vec{e})}{v}}
\qquad
%% Def	
\nru{\infdef}
{\Sig \; \ff \; = (\_,v,\_) }
{\Infer{k}{\rho_1}{\rho_2}{\ff}{v}}
%% Con 
\\[2ex]
\nru{\infcon}
{\Sig \; \cc \; = v}
{\Infer{k}{\rho_1}{\rho_2}{\cc}{v}} 
%% Const
\qquad
\nru{\infconst}
{\Sig \; \dd \; = (\_,\_,\_,v,\_)}
{\Infer {k}{\rho_1}{\rho_2}{\dd}{v}}
\end{gather*}

\caption{Infering type of expressions}
\end{figure}

\begin{figure}[p]
\begin{gather*}
%% Force L
\nru{\eqlf}
{\forc \; v_1 = u_1 \qquad \forc \; v_2 = \stuck 
\qquad
f \neq \rF \qquad \FeqVal{\lF}{k}{u_1}{v_2}}
{ \EqVal{f}{k}{v_1}{v_2}}
%% Force R
\\[2ex]
\nru{\eqrf}
{\forc \; v_1 = \stuck \qquad \forc \; v_2 = u_2 
\qquad
f \neq \lF \qquad \FeqVal{\rF}{k}{v_1}{u_2}}
{ \EqVal{f}{k}{v_1}{v_2}}
\\[2ex]
%% Force N
\nru{\eqnf}
{\FeqVal{f}{k}{v_1}{v_2}}
{ \EqVal{f}{k}{v_1}{v_2}}
\qquad
%% Set
\nru{\eqset}
{}
{\FeqVal{f}{k}{\Set}{\Set}}
%% Size
\\[2ex]
\nru{\eqsize}
{}
{\FeqVal{f}{k}{\Size}{\Size}}
%% Infty
\qquad
\nru{\eqinfty}
{}
{\FeqVal{f}{k}{\infty}{\infty}}
%% Succ
\\[2ex]
\nru{\eqsuc}
{\EqVal{f}{k}{v_1}{v_2}}
{\FeqVal{f}{k}{\s v_1}{\s v_2}}
%% App
\qquad
%% Gen
\nru{\eqgen}
{}
{\EqVal{f}{k}{k'}{k'}}
\\[2ex]
\nru{\eqapp}
{\EqVal{f}{k}{v_1}{v_2} \qquad
\EqVal{f}{k}{c_1}{d_1} \ldots \EqVal{f}{k}{c_n}{d_n}}
{\FeqVal{f}{k}{v_1 (c_1 \ldots c_n)}{v_2 (d_1 \ldots d_n)}}
%% Pi
\\[2ex]
\nru{\eqpi}
{\EqVal{f}{k}{a_1}{a_2}
\qquad
\EqVal{f}{k+1}{\wh b_1 (\ins \; \rho_1 \; (x_1,k))}{\wh b_2 (\ins \; \rho_2 \; (x_2,k))}}
{\FeqVal{f}{k}{\vpi \; x_1 \; a_1 \; \cl{b_1}{\rho_1}}{\vpi \; x_2 \; a_2 \; \cl{b_2}{\rho_2}}}
%% Lam
\\[2ex]
\nru{\eqlam}
{\EqVal{f}{k+1}{\wh b_1 (\ins \; \rho_1 \; (x_1,k))}{\wh b_2 (\ins \; \rho_2 \; (x_2,k))}}
{\FeqVal{f}{k}{\vlam \; x_1 \; \cl{b_1}{\rho_1}}{\vlam \; x_2 \; \cl{b_2}{\rho_2}}}
%% Def
\\[2ex]
\nru{\eqdef}
{}
{\FeqVal{f}{k}{\ff}{\ff}}
%% Con
\qquad
\nru{\eqcon}
{}
{\FeqVal{f}{k}{\cc}{\cc}}
\end{gather*}
\caption{equality checking}
\end{figure}

\subsubsection{Datatype declarations}
We require that datatype delcarations are strictly positive.
Otherwise there are inconsistencys (\cite{paulinmohring93inductive}).
\newcommand{\nocc}[3]{#1\vdash#2\:\mbox{nocc}\:#3}

\begin{figure}
\begin{gather*}
\nru{}
{\nocc{k}{i}{v_a} \qquad \nocc{k+1}{i}{\wh \cl{b}{\ins \; \rho \; (x,k)}}}
{\nocc{k}{i}{\vpi \; x \; v_a \; \cl{b}{\rho}}  }
\\[2ex]
\nru{}
{\nocc{k}{i}{v} \qquad \nocc{k}{i}{\wh c_j} \mbox{ for all } j \in \{1 \ldots n \}}
{\nocc{k}{i}{v \; c_1 \ldots c_n}}
\qquad
\nru{}
{\nocc{k}{i}{v}}
{\nocc{k}{i}{\s v}}
\\[2ex]
\nru{}
{i \neq i'}
{\nocc{k}{i}{i'}}
\qquad
\nrux{}
{}
{\nocc{k}{i}{v}}
{\mbox{otherwise}}
\end{gather*}
\caption{Nonoccurence of generic variable i}
\end{figure}

\newcommand{\spos}[3]{#1\vdash#2\:\mbox{spos}\:#3}

\begin{figure}
\begin{gather*}
\nru{}
{ \nocc{k}{i}{v_a} \qquad \spos{k+1}{i}{\wh \cl{b}{\ins \; \rho \; (x,k)}}}
{\spos{k}{i}{\vpi \; x \; v_a \; \cl{b}{\rho}}  }
\\[2ex]
\ndru{}
{\Sig \DD = (\mbox{Pos},\_,\_,\_) \qquad \nocc{k}{i}{\wh v_j} \mbox{ for all } j \in \{1 \ldots m \}} 
{\spos{k}{i}{\wh p_j} \mbox{ for all } j \in \mbox{Pos} \qquad \nocc{k}{i}{\wh p_j} \mbox{ for all } j \notin \mbox{Pos} } 
{\spos{k}{i}{\DD p_1 \ldots p_n \; c_1 \ldots c_m}}
\\[2ex]
\nru{}
{\spos{k}{i}{v} \qquad \nocc{k}{i}{\wh c_j} \mbox{ for all } j \in \{1 \ldots n \}}
{\spos{k}{i}{v \; c_1 \ldots c_n}}
\\[2ex]
\nru{}
{\spos{k}{i}{v}}
{\spos{k}{i}{\s v}}
\qquad
\nrux{}
{}
{\spos{k}{i}{v}}
{\mbox{otherwise}}
\end{gather*}
\caption{Strictly positive occurence of generic variable i}
\end{figure}

In table x we give rules for the strict positiv occurence of a generic variable $i$ in a type value.
It relies on the non-occurence defined in table y.
These judgement can be defined analougsly for the occurence of a data identifier $\DD$.
\begin{definition}
A constructor $v$ for $\DD$ is strictly positive, if $\spos{0}{\DD}{v}$ and 
$\spos{0}{i}{v}$ for every $i \in \mbox{Pos}\; {\DD}$  
\end{definition}

Later the information about positive parameters will be usefull for subtyping.

\begin{bsp}
$\data \Bad : \Set $ \\
$\spc \ok : \Bad$\\
$\spc \bad : ((\Nat \ra \Bad) \ra \Bad) \ra \Bad  $
\end{bsp}
is not allowed because of the non-positive occurence of $\Bad$ in the argument of $\bad$.

\begin{bsp}
$\data \Bad : ( + A : \Set ) : \Set $\\
$\spc \ok : \Bad A$\\
$\spc \bad : (A \ra \Bad) \ra \Bad A$
\end{bsp}
is not allowed because of the negative occurence of $A$ in the argument of $\bad$.

\subsubsection{Function declarations}

\newcommand{\subst}[2]{#1\{#2\}}
\newcommand{\substClos}[2]{#1\{#2\}}
\newcommand{\substEnv}[2]{#1\{#2\}}
\newcommand{\compS}[2]{\mathrm{compS}#1\;#2}

\begin{definition}
A substitution $\sigma : \ves{(\cN \times \Val)} $ denotes a partial mapping of generic variables to values.
$\diamond$ is the empty substitution.
$\sigma[k \rightarrow v] $ maps $k$ to $v$ and all other variables according to $\sigma$
\end{definition}
We define simultaneously the application of a substitution on values,closures and environments.
\[
\begin{array}{ll}
\multicolumn{2}{l}{\subst{\_}{\_} : \ves{(\cN \times \Val)} \ra \Val \ra \Val} \\
\subst{\sigma}{k} & = v \mbox{ if } (k,v) \in \sigma \\
\subst{\sigma}{v cl_1 \ldots cl_n} & = \subst{\sigma}{v} \substClos{\sigma}{c_1} \ldots \substClos{\sigma}{c_n}\\
\subst{\sigma}{\s v} & = \s \subst{\sigma}{v} \\
\subst{\sigma}{\vpi x v_a \cl{b}{\rho}} & = \vpi x \subst{\sigma}{a_v} \cl{b}{\subst{\sigma}{\rho}} \\
\subst{\sigma}{\vlam x \cl{b}{\rho}} & = \vpi x \cl{b}{\subst{\sigma}{\rho}} \\
\subst{\sigma}{v} & = v \mbox{ othewise }
\end{array}
\]

\[
\begin{array}{ll}
\multicolumn{2}{l}{\substClos{\_}{\_} : \ves{(\cN \times \Val)} \ra \Clos \ra \Clos} \\
\substClos{\sigma}{\cl{e}{\rho}} & = \cl{e}{\substEnv{\sigma}{\rho}} 
\end{array}
\]


\[
\begin{array}{ll}
\multicolumn{2}{l}{\substEnv{\_}{\_} : \ves{(\cN \times \Val)} \ra \Env \ra \Val} \\
\substEnv{\sigma}{\diamond} & = \diamond \\
\substEnv{\sigma}{(x,v)\rho} & = (x,\subst{\sigma}{v}) \substEnv{\sigma}{\rho} \\
\substEnv{\sigma}{(x,c)\rho} & = (x,\substClos{\sigma}{c}) \substEnv{\sigma}{\rho}
\end{array}
\]

Now we define composition of two substitutions $\sigma_1$ and $\sigma_2$.
It is assumed that the domains of the substituions are disjunct and
ther are no occurences of the variables of $\sigma_1$ in the values of the codomain of $\sigma_2$.  
\[
\begin{array}{ll}
\multicolumn{2}{l}{\compS : \ves{(\cN \times \Val)} \ra \ves{(\cN \times \Val)} \ra \ves{(\cN \times \Val)}} \\
\compS{\sigma_1}{\sigma_2} & =  \sigma'_1 \sigma_2 \mbox{ where } (x,\subst{\sigma_2}{v}) \in \sigma'_1 \mbox{ iff } (x,v) \in \sigma_1 \\
\end{array}
\]

\newcommand\checkcl[2]{#1\mbox{ \textbf{checkcl}}#2}
\newcommand\checkp[5]{(#1)\vdash#2\mbox{ \textbf{checkp} }#3\Rightarrow (#4),#5}
\newcommand\checkps[5]{(#1)\vdash#2\mbox{ \textbf{checkps} }#3\Rightarrow (#4),#5}
\newcommand\checkinacc[2]{(#1)\vdash\mbox{ \textbf{checkinaccs} }#2}
\newcommand\inst[5]{#1,#2\vdash#3\mbox{ \textbf{inst} }#4\Rightarrow #5}
\newcommand\instlist[5]{#1,#2\vdash#3\mbox{ \textbf{instList} }#4\Rightarrow #5}

\newcommand\ptc{\mathrm{p2c}}
\newcommand\inaccenv{\mathrm{inaccEnv}}
\newcommand\pte{\mathrm{p2e}}
\newcommand\pstes{\mathrm{ps2es}}


\[
\checkp{(k,f,\sigma,\rho_1,\rho_2)}{p}{v}{(k',f',\sigma',\rho'_1,\rho'_2,v')}
\]

\[
\begin{array}{ll}
\multicolumn{2}{l}{\ptc : \cN \times \Env \times \ves{\cN} \times \Pat \ra \Clos}\\
\ptc k \rho f p & = \cl{e}{\rho_2} \mbox{ where } \\
& (e,k') = \pte k p \\
& \rho_2 = \inaccenv \rho k f \\
\multicolumn{2}{l}{\pte : \cN \times \Pat \ra (\Expr,k)}\\
\pte k x & = (x,k+1) \\
\pte k (\cc \diamond) & = (\cc,k) \\
\pte k (\cc \vec{p}) & = (\cc \vec{e},k') \mbox{ where } (\vec{e},k') = \pstes k \vec{p}\\
\pte k (\s p) & = (\s e,k') \mbox{ where } (e,k') = \pte k p\\
\pte k \inacc{e} & = (i_k,k+1) \\
\multicolumn{2}{l}{\inaccenv : \Env \times \cN \times \ves{cN} \ra \Env}\\
\inaccenv \rho k \diamond & = \rho \\
\inaccenv \rho k (f \vec{f}) & = \inaccenv \rho k \vec{f} \mbox{ if } f < k  \\
\inaccenv \rho k (f \vec{f}) & = \ins (i_f,f) (\inaccenv \rho k \vec{k}) \mbox { if } f \geq k 
\end{array}
\]

\begin{figure}
\begin{gather*}
\ndru{}
{\checkps
{0,\diamond,\diamond,\diamond,\diamond}
{\vec{p}}{v_t}{k,f,\sigma,\rho_1,\rho_2}{v_e}}
{\checkinacc{k,\sigma,\rho_2}{f} 
\qquad
\Check{k}{\rho_1}{\rho_2}{e}{v_e}
}
{
\checkcl{v_t}{\ff \vec{p} e}
}
\end{gather*}
\caption{Checking a clause}
\end{figure}

\begin{figure}
\begin{gather*}
% VAR
\nru{\chkpvar}
{v_b = \wh \cl{b}{\ins \rho (x,k)}}
{
\checkp
{k,f,\sigma,\rho_1,\rho_2}
{y}
{\vpi x v_a \cl{b}{\rho}}
{k+1,f,\sigma,\ins \rho_1 (y,k),\rho_2 (y,v_a)}
{v_b}}
% CON
\\[2ex]
\nxru{\chkpcon}
{\Sig{\cc}=v_c \qquad
\checkps{k,f,\sigma,\rho_1,\rho_2}
{\vec{p}}
{v_c}
{k',f',\sigma',\rho'_1,rho'_2}
{v'_c}
}
{\inst{k}{f}{v'_c}{v_a}{\sigma_2} \qquad
\ptc k \rho'_1 f p =  c}
{\sigma'' = \compS{\sigma'}{\sigma_2} \qquad
\rho''_2 = \substEnv{\sigma''}{\rho'_2} \qquad
v_b = \subst{\sigma''}{\wh \ins \rho (x,c)}
}
{\checkp
{k,f,\sigma,\rho_1,\rho_2}
{\cc \vec{p}}
{\vpi x v_a \cl{b}{\rho}}
{k',f',\sigma'',\rho'_1,\rho''_2}
{v_b}
}
% SUCC
\\[2ex]
\ndru{\chkpsucc}
{
\checkp{k,f,\sigma,\rho_1,\rho_2}{p}{\wh \clp{\Size \ra \Size}{\diamond}}
{k',f',\sigma',\rho'_1,\rho'_2}{v'}}
{
\EqVal{k'}{\nF}{v_a}{v'} \qquad
\ptc k \rho'_1 f p = c
}
{
\checkp
{k,f,\sigma,\rho_1,\rho_2}
{\s p}
{\vpi x v_a \cl{b}{\rho}}
{k',f,\sigma,\ins \rho_1 (y,k),\rho_2 (y,v_a)}
{v_b}}
% DOT
\\[2ex]
\nru{\chkpinacc}
{v_b = \wh \cl{b}{\ins \rho (x,k)}}
{
\checkp
{k,f,\sigma,\rho_1,\rho_2}
{\inacc{e}}
{\vpi x v_a \cl{b}{\rho}}
{k+1,(k,e)f,\sigma,\rho_1,\rho_2}
{v_b}}
\end{gather*}
\caption{Checking a pattern}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{}
{
\checkps
{k,f,\sigma,\rho_1\rho_2}
{\diamond}
{v}
{k,f,\sigma,\rho_1,\rho_2}
{v}}
\\[2ex]
\ndru{}
{\checkp
{k,f,\sigma,\rho_1,\rho_2}
{p}
{v}
{k',f',\sigma',\rho'_1,\rho'_2}
{v'}
}
{\checkps
{k',f',\sigma',\rho'_1,\rho'_2}
{\vec{p}}
{v'}
{k'',f'',\sigma'',\rho''_1,\rho''_2}
{v''}
}
{
\checkps
{k,f,\sigma,\rho_1\rho_2}
{p \vec{p}}
{v}
{k'',f'',\sigma'',\rho''_1,\rho''_2}
{v''}}
\end{gather*}
\caption{Checking multiple patterns}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{}
{
\checkinacc
{k,\sigma,\rho_1}
{\diamond}
}
\\[2ex]
\ndru{}
{
(i,v) \in \sigma \qquad
\EqVal{k}{v}{\wh \cl{e}{\rho_1}}{v}
}
{
\checkinacc
{k,\sigma,\rho_1}
{\vec{f}}
}
{
\checkinacc
{k,\sigma,\rho_1}
{(i,e) \vec{f}}
}
\end{gather*}
\caption{Checking inaccesible patterns}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{}
{
\checkps
{k,f,\sigma,\rho_1\rho_2}
{\diamond}
{v}
{k,f,\sigma,\rho_1,\rho_2}
{v}}
\\[2ex]
\ndru{}
{\checkp
{k,f,\sigma,\rho_1,\rho_2}
{p}
{v}
{k',f',\sigma',\rho'_1,\rho'_2}
{v'}
}
{\checkps
{k',f',\sigma',\rho'_1,\rho'_2}
{\vec{p}}
{v'}
{k'',f'',\sigma'',\rho''_1,\rho''_2}
{v''}
}
{
\checkps
{k,f,\sigma,\rho_1\rho_2}
{p \vec{p}}
{v}
{k'',f'',\sigma'',\rho''_1,\rho''_2}
{v''}}
\end{gather*}
\caption{Checking multiple patterns}
\end{figure}

\begin{figure}
\begin{gather*}
\nru{}
{}
{
\checkinacc
{k,\sigma,\rho_1}
{\diamond}
}
\\[2ex]
\ndru{}
{
(i,v) \in \sigma \qquad
\EqVal{k}{v}{\wh \cl{e}{\rho_1}}{v}
}
{
\checkinacc
{k,\sigma,\rho_1}
{\vec{f}}
}
{
\checkinacc
{k,\sigma,\rho_1}
{(i,e) \vec{f}}
}
\end{gather*}
\caption{Checking inaccesible patterns}
\end{figure}


\begin{figure}
\begin{gather*}
\nru{}
{}
{\inst{k}{f}{k'}{v}{(k',v)}}
%
\nru{}
{}
{\inst{k}{f}{v}{k'}{(k',v)}}
%
\\[2ex]
\nru{}
{{\instlist{k}{f}{\wh{c_1} \ldots \wh{c_n}}{\wh{d_1} \ldots \wh{d_n}}{\sigma}}}
{\inst{k}{f}{\DD c_1 \ldots c_n}{\DD d_1 \ldots d_n}{\sigma}
}
\\[2ex]
\nru{}
{{\instlist{k}{f}{\wh{c_1} \ldots \wh{c_n}}{\wh{d_1} \ldots \wh{d_n}}{\sigma}}}
{\inst{k}{f}{\cc c_1 \ldots c_n}{\cc d_1 \ldots d_n}{\sigma}
}
\\[2ex]
\nru{}
{\inst{k}{f}{v_1}{v_2}{\sigma}}
{\inst{k}{f}{\s v_1}{\s v_2}{\sigma}
}
\nru{}
{\inst{k}{f}{v_1}{\infty}{\sigma}}
{\inst{k}{f}{\s v_1}{\infty}{\sigma}
}
\\[2ex]
\nru{}
{\EqVal{k}{N}{v_1}{v_2}}
{\inst{k}{f}{v_1}{v_2}{\diamond}
}
\nru{}
{}
{\instlist{k}{f}{\diamond}{\diamond}{\diamond}}
\\[2ex]
\ndru{}
{\inst{k}{f}{v_1}{w_1}{\sigma}}
{\instlist{k}{f}{\subst{\sigma}{v_2} \ldots \subst{\sigma}{v_n}}{\subst{\sigma}{w_2} \ldots \subst{\sigma}{w_n}}{\sigma'}}
{\instlist{k}{f}{v_1 v_2 \ldots v_n}{w_1 w_2 \ldots w_n}{\compS \sigma \sigma'}}
\end{gather*}
\caption{Instantiating flexible variables}
\end{figure}

\subsubsection{Constant declaration}

\section{Pattern matching}
Dependend pattern matching was introduced by Thierry Coquand in \cite{coquand92pattern}.
The patterns for all the clauses of a function are assumed to be complete. This means that during runtime
it is guaranteed that matching always succeeds.

\chapter{Termination Checking}

\newcommand{\order}{\mathrm{Order}}
\section{Structural recursion}

\begin{definition}[Order]
\[ O := \{ < , \leq , ? \} \]
\end{definition}
Axiom1:
\[ e \; < \; C \; \vec{e_1} \; e \; \vec{e_2} \]
\\
Axiom2:
\[ f \; \vec{e} \; \leq \; f \] 

Axiom 2 is needed for higher order data types like $\Ord$.

\begin{definition}[Order Addition]
\[
\begin{array}{l | c |c | c }

 +    &  <   &  \leq   &  ? \\
 \hline 
 <    &  <   & <       &  < \\
 \leq &  <   & \leq    &  <  \\
 ?    &  <   & \leq    &  ?
\end{array}
\]

\end{definition}


\begin{definition}[Order multiplication]
\[
\begin{array}{l | c |c | c}
 *   &  <  &  \leq & ? \\
\hline
  <   & <    & <    &   ? \\
 \leq & <    & \leq &   ?  \\
 ?    & ?    & ?    &   ?
\end{array}
\]
\end{definition}

\begin{definition}{Relating patterns and arguments}
\end{definition}

The following definitons are taken from \cite{abelAltenkirch:predStRec}

\begin{definition}
An expression of the form $\ff \vec{e}$ is called a call.
\end{definition}

\newcommand{\mino}{\mathrm{min}\;}
\newcommand{\maxo}{\mathrm{max}\;}
\newcommand{\supo}{\mathrm{sup}\;}
\newcommand{\info}{\mathrm{inf}\;}

\begin{definition}[Order minimum]
\[
\begin{array}{l | c |c | c}
 \mino &  <      &  \leq    & ? \\
\hline
  <    & <       &  \leq    &   ? \\
 \leq  & \leq    &  \leq    &   ?  \\
 ?     & ?       &  ?       &   ?
\end{array}
\]
\end{definition}

\begin{definition}[Order maximum]
\[
\begin{array}{l | c |c | c}
 \maxo & <      &  \leq    &   ? \\
\hline
  <    & <       & <       &   <    \\
 \leq  & <       & \leq    &   \leq  \\
 ?     & <       & \leq    &   ?
\end{array}
\]
\end{definition}

\begin{definition}[Order supremum]
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\supo : \ves{\order} \ra \order}\\ 
\supo \diamond = ? \\
\supo (o \vec{o} ) = \maxo o \; (\supo \vec{o}) \\
\end{array}
\]
\end{definition}

\begin{definition}[Order infimum]
\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\info : \ves{\order} \ra \order}\\ 
\info \diamond = < \\
\info (o \vec{o} ) = \mino o \; (\info \vec{o}) \\
\end{array}
\]
\end{definition}

\newcommand{\cmp}{\mathrm{compare}\;}
\newcommand{\cmpv}{\mathrm{compareVar}}
\newcommand{\cmps}{\mathrm{compareSize}}
\newcommand{\cmpsv}{\mathrm{compareSizeVar}}
\newcommand{\etp}{\mathrm{etp}\;}


\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmp : \Expr \times \Pat \ra \order}\\ 
\cmp e_1 \; \inacc{e_2} & = \cmp e_1 \; p \mbox{ if } \etp e_2 = p \\
\cmp x \; p & = \cmpv x \;p  \mbox{ where } x \in \cV \\
\cmp (\cc e_1 \ldots e_i) \; (\cc p_1 \ldots p_j ) & = \info (\cmp e_1 p_1) \ldots (\cmp e_m p_m)\\
& \; \mbox { where } m = min\{i,j\}\\ 
\cmp \cc \; (\cc \diamond) & = \leq \\
\cmp (\s e_1) \; (\s e_2) & = \cmp e_1 \; e_2 \\
\cmp (f \vec{e}) \; f & = \leq \mbox{ where } f \in \cV \\
\cmp e \; p & = ? \mbox{ otherwise}
\end{array}
\]

\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\etp : \Expr \ra \Pat}\\ 
\etp x & = x \mbox{ where } x \in \cV \\
\etp (\cc e_1 \ldots e_n ) & = \cc (\etp e_1) \ldots (\etp e_n) \\
\etp \cc  & = \cc \diamond \\
\etp (\s e) = \s (\etp e) \\
\etp e = \stuck \mbox{ otherwise}
\end{array}
\]

\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmpv : \cV \ra \Pat \ra \order}\\ 
\cmpv x \; x & = \leq \\
\cmpv x \; (\cc p_1 \ldots p_n ) & = < * \; \supo (\cmpv p_1) \ldots (\cmpv p_n) \mbox{ if } \cc \mbox{ is inductive }\\   \\
\cmpv x \; \inacc{e} & = \cmpv x p \mbox{ if } \etp e = p \\
\cmpv x \; \s p & = ? \\
\cmpv x \; (\cc \vec{p}) & = ? \mbox{ where } \cc \mbox{ is coinductive}\\
\cmpv x \; p & = ? \mbox{ otherwise}
\end{array}
\]

\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmps : \Expr \ra \Pat \ra \order}\\ 
\cmps e_1 \; \inacc{e_2} & = \cmp e_1 \; p \mbox{ if } \etp e_2 = p \\
\cmps x \; p & = \cmpsv x \;p  \mbox{ where } x \in \cV \\
\cmps (\s e_1) \; (\s e_2) & = \cmps e_1 \; e_2 \\
\cmps e \; p & = ? \mbox{ otherwise}
\end{array}
\]

\[
\begin{array}[t]{ll}
\multicolumn{2}{l}{\cmpsv : \cV \ra \Pat \ra \order}\\ 
\cmpsv x \; x & = \leq \\
\cmpsv x \; \inacc{e} & = \cmpv x p \mbox{ if } \etp e = p \\
\cmpsv x \; \s p & = < * \; \cmpsv x \; p \\
\cmpsv x \; p & = ? \mbox{ otherwise}
\end{array}
\]

Note that coinductive objects are not well-founded. So we do have $\cmp x (\cc x) = ? $ when $\cc$ is a coinductive construcotor.
Also we have $\cmp x \; (\s x) = ? $ because the size type is not well-founded.
We will later allow the judgment $x < \s x$ for admissble size arguments.

\begin{definition}
CallMatrix. Let $f (p_1 \ldots p_n) e$ be a function clause and $g (e_1 \ldots e_n$ be a call in $e$.
The associated call matrix is defined by $(f,M,g)$ where
\[ M(i,j) = \cmp p_i e_j \]
\end{definition}

\begin{definition}[Call Matrix multiplication]
\[(f,M_1,g) \times (g,M_2,h) := (f,M_1 \times M_2,h)\]
\end{definition}

\begin{definition}[Call Graph]
A finite set of Call matrices is called a \emph{call graph}
\end{definition}

\begin{definition}[Call Graph completion]
Call graph completion is closing the set under multiplication.
Completion of a finite set is also finite. 
\end{definition}

\section{Size change principle}

The termination criterion in \cite{abelAltenkirch:predStRec} can be replaced with the
simpler and more powerful criterion from \cite{lee01sizechange}
Their formalism is based on bipartit graphs instead of call matrixes, but these are
equivalent representations.

\begin{definition}
A callmatrix (f,M,f) is \emph{idempotent} if $ M \times M = M $ 
\end{definition}

\begin{definition}[Size change principle]
A function f is terminating, if every idempotent callmatrix  $ \in \mathrm{complete g} $ from f to f has a decreasing element $<$ on
the diagonal.
\end{definition}

David Wahlstedt proofs the soundness of the size-change principle for a depently typed language 
for first order data types (no function space in constructor arguments, so Axiom 2 is not needed ).
Andreas Abel has shown the soundness of the structual order defined by Axiom 1 and 2 for the simple typed
language foetus.
Note that the order from Axiom 1 and 2 is actually not valid in impredicative systems.

\begin{figure}[p]
\[
\mathrm{add}\begin{pmatrix}

\leq & ? \\
?    & < \\

\end{pmatrix}\mathrm{add}
\]
\caption{add call matrix}
\end{figure}

\begin{figure}[p]

\[
\mathrm{add'} \begin{pmatrix}

? & \leq \\
< & ?   \\

\end{pmatrix} \mathrm{add'}
\]

\caption{initial add' call matrix}

\end{figure}

\begin{figure}[p]

\[
\mathrm{add'} \begin{pmatrix}

< & ?    \\
? & <    \\

\end{pmatrix} \mathrm{add'}
\] 

\caption{idempotent add' call matrix}

\end{figure}

\section{Examples}

\subsection{Brouwer ordinals}
The so called Brouwer ordinal notations can be defined with
\begin{bsp}
$\data \Ord : \Set$ \\
$\spc \ozero : \Ord $\\
$\spc \olim : (\Nat \ra \Ord ) \ra \Ord $
\end{bsp}
This is an example of a higher-order data type, because the argument to $\olim$ contains a function space.
Now let's define ordinal addition:
\begin{bsp}
$\fun \addOrd : \Ord \ra \Ord \ra \Ord$\\
$\spc \addOrd x \; \ozero = x $\\
$\spc \addOrd x (\olim f) = \olim ( \lam{y} \addOrd  x \; (f \; y))  $
\end{bsp}
Axiom 2 is needed to show that the recursive call happens on a smaller argument.
\section{Extending the Order}
Definition of pair data type.
But now, the uncurried versions do no longer termination check.
The reason is that we need to keep the information.
\begin{definition}[MOrder]
\[ MO := \{ < , \leq , ? , MO^{r,n}\} \]
\end{definition}

\begin{definition}[Order Addition]
\[
\begin{array}{l | c |c | c | c}

 +    &  <   &  \leq   &  ? & M \\
 \hline 
 <    &  <   & <       &  < &  \\
 \leq &  <   & \leq    &  < &  \\
 ?    &  <   & \leq    &  ? &  \\
 M    &      &         &  M &  
\end{array}
\]

\end{definition}


\begin{definition}[Order multiplication]
\[
\begin{array}{l | c |c | c| c }
 *    &  <  &  \leq &   ? & M \\
\hline
  <   & <    & <    &   ? &   \\
 \leq & <    & \leq &   ? &   \\
 ?    & ?    & ?    &   ? &   \\
 M    &      &      &   ? &
\end{array}
\]
\end{definition}

\begin{definition}[Completion with extended order]
is also finite because matrices are only getting smaller or a collapsed to a single value.
\end{definition}

\section{Examples}


\subsection{Huet list reversion}
First, we present a peculiar list reversion algorithm.

The algorithm cannot be verified terminating.
Note that the recursive calls don't happen directly on subcomponents of the argument.
but are passed through another function.
We would need the information that revb does not increase the size of the list to ensure termination.
We can fix this by using vectors instead of lists:

Now the termination checker can verify the termination.
So we note that better type information helps the termination checker.
But using vectors instead of lists is not always easily possible.
Consider a filter function on Lists. We only know that this function does not increase the size, but
we don't know the exact length.
This is one of the reasons we will introduce a special size type in the next chapter.

\begin{figure}
$\mutual $  \\
$ \spc \fun \rev : \EPi{A}{\Set}{\List A \ra  \List A} $ \\
$ \spc \spc \rev .A \; (\nil A ) = \nil A$\\
$ \spc \spc \rev .A \; (\cons A \;x  \; xs) = \cons A \; (\reva A \; x \; xs) (\revb A \; x \; xs)$\\
$\ \spc \fun \reva : \EPi{A }{\Set}{A  \ra \List A \ra A}$\\
$ \spc \spc \reva .A \; a \; (\nil A ) = a$ \\
$\spc \spc \reva .A \; a (\cons A \; x \; xs) = \reva A \; x \; xs$\\
$\spc \fun \revb : \EPi{A}{\Set}{ A \ra \List A \ra \List A} $\\
$\spc \spc \revb .A \; a \; (\nil A ) = \nil A $\\
$\spc \spc \revb .A \; a (\cons A\;  x \; xs) = \rev A (\cons A \; a \; (\rev A \; (\revb A \; x \; xs)))$

\caption{reversion on Lists}  
\end{figure}
\begin{figure} 
$\mutual $ \\
$\spc \fun \rev : \EPi{n}{\Nat }{\EPi{A}{\Set }{\vVec A \; n \ra \vVec A \; n}}$\\
$\spc \spc \rev .zero \; .A  \; (\nil A) = \nil A $\\
$\spc \spc \rev .(\suc n) .\; A (\cons A \; n \; x \; xs) = $\\
$\spcx \cons A \; n \; (\reva n \; A \; x \; xs) (\revb n \; A \; x \; xs) $ \\
$\spc \fun \reva : \EPi{n}{\Nat}\EPi{A}{\Set}{A \ra Vec A \; n \ra A}$\\
$\spc \spc \reva .zero  \; .A \; a \; (\nil A) = a $\\
$\spc \spc \reva .(\suc n) .A \; a \; (\cons A \; n \; x \; xs) = \reva n \; A \; x \; xs $\\
$\spc \fun \revb : \EPi{n}{\Nat}{\EPi{A}{\Set}{A \ra \vVec A \; n \ra \vVec A \; n}}$\\
$ \spc \spc \revb .zero \; .A  \; a \; (\nil A) = \nil A $\\
$ \spc \spc \revb .(\suc n) \; .A \; a (\cons A \; n \; x \; xs) = $\\
$ \spcx \rev (\suc n) A (\cons A \; n \; a (\rev n \; A \; x \; xs))$
\caption{reversion on vectors}  
\end{figure}  

\chapter{Adding a Size Type}
Traditionally, size annotation have been used in the typing rules.
We take a different approach.
Wie add a primitive size type, and then use the current termination checker to see that the size is 
decreasing.
\section{Syntax}

Expressions:
\begin{itemize}
\item
size type: $ \Size $ 
\item
size succesor: $\s e $ 
\item
infinity: $\infty$ 
\end{itemize}
Patterns:
\begin{itemize}
\item
size succesor pattern:$ \s p $ 
\end{itemize}
Note that we also have variables of type $\Size$.
As such, expressions of type size form the stage expression of Barthe et. al :  $ i , \s i $ and $ \infty $ .
\section{Sized types definition}
We now declare what a sized type is.
\begin{definition}
A datatype D is a sized type, if $ \Size \ra A $ is its type
For every constructor 
\begin{itemize}
\item
it begins with $(i: Size)$
\item
the result type is $D \dots (\s i) \dots $
\item
every rec. argument is of the form $ D \dots i \dots $
\end{itemize}
\end{definition}
\section{Matching against infinity}
The equation 
$[ s \infty = \infty $
needs to be taken into account when evaluating a function application.
So whhen the pattern $ s \; x $ is matches against $ \infty $ , $x$ will be bound to $ \infty $  
\section{Interpretation of the Size type}
One may see the size type as a coniductive data type - the dual to natural numbers, the conatural numbers.
\section{Examples}
\subsection{Sized Lists}
\begin{bsp}
$\data \List ( A : \Set ) : \Size \ra \Set $ \\
$\spc \nil : \EPi{i}{\Size}{ \List A \; (\s i)} $\\
$\spc \cons : \EPi{i}{\Size}{ A \ra \List A \; i \ra \List A \; (\s i)} $
\end{bsp}

What is the differnce between vectors and sized lists ?
The size index is only used for relativ comparisons, its not an exact number, but an upper bound.
This enables subtyping, and one can compromise by forgetting the exact size ($\infty$).
For example, splitting a vector of length n, we need to show that there exist j,k such that $j+k = n$.
With sized type, we don't need to be that exact.
\subsection{Sized natural numbers}
\begin{bsp}
$\data \SNat : \Size \ra \Set $ \\
$\zero : \EPi{i}{\Size}{ \SNat \; (\s i)} $\\
$\suc : \EPi{i}{\Size}{ \SNat \; i \ra \SNat \; (\s i)} $
\end{bsp}

\subsection{Great common divisor}

\subsection{Quicksort}
\begin{bsp}
$\data \ProdT ( + A : \Set) : \Set$\\
$\spc  \prd : A \ra A \ra \ProdT A$\\
$\fun \pra : ( A : \Set ) \ra \ProdT A\; \ra A$\\
$\spc \pra \inacc{A}\; (\prd A\; a b) = a$\\
$\fun \prb : ( A : \Set ) \ra \ProdT A\; \ra A$\\
$\spc \prb \inacc{A}\; (\prod A\; a b) = b$\\
$\fun \ite : (A : \Set ) \ra \Bool \ra A \ra A \ra A$\\
$\spc \ite A\; \tt x\; y\; = x$\\
$\spc \ite A\; \ff x\; y\; = y$\\
%%
$\fun \pivot : (i : \Size ) \ra (A : \Set ) \ra ( \lleq : A \ra A \ra \Bool )$\\ 
$\spcx	\ra A \ra \List A\; i\; \ra \ProdT (\List A\; i)$\\
$\spc\pivot \inacc{\s i}\;     \inacc{A}\; \lleq a\; (\nil A\; i) = \prd (\List A\; (\s i))\;(\nil A\; i)\;(\nil A\; i)$\\
$\spc \pivot \inacc{\s i}\;    \inacc{A}\; \lleq a\; (\cons A\; i x\; xs) =$\\ 
$\spcx     \ite (\ProdT (\List A\; (\s i)))\; (\lleq a\; x)$\\ 
$\spcx    (\prd (\List A\; (\s i))$\\
$\spcx \spc       (\pra (\List A\; i)\; (\pivot i\; A\; \lleq a\; xs)) $\\
$\spcx \spc	(\cons A\; i\; x\; (\prb (\List A\; i) \; (\pivot i\; A\; \lleq a\; xs))))$\\ 
$\spcx     (\prd (\List A\; (\s i))$\\
$\spcx	\spc (\cons A\; i\; x\; (\pra (\List A\; i)\; (\pivot i\; A\; \lleq a\; xs)))$\\
$\spcx  \spc (\prb (\List A\; i)\; (\pivot i\; A\; \lleq a\; xs)))$\\
%%
$ \fun \qsapp : (i : \Size ) \ra ( A : \Set ) \ra ( \lleq : A \ra A \ra \Bool )$\\ 
$\spcx	\ra \List A\; i \ra \List A\; \infty \ra \List A\; \infty$\\
$\spc \qsapp \inacc{\s i}\; \inacc{A}\; \lleq (\nil A\; i) \;      ys = ys;$\\
$\spc \qsapp \inacc{\s i}\; \inacc{A}\; \lleq (\cons A\; i\; x\; xs) \; ys = \qsapp i\; A\; \lleq$\\ 
%%
$\spcx	(\pra (\List A\; i) (\pivot i\; A\; \lleq x\; xs))$\\
%%    	
$\spcx	(\cons A\; \infty \; x\; $\\
$\spcx	\spc   (\qsapp i\; A\; \lleq (\prb (\List A\; i) \; (\pivot i\; A\; \lleq x\; xs))\; ys))$\\
%%
$\fun \quicksort : (i : \Size ) \ra (A : \Set ) \ra (\lleq : A \ra A \ra \Bool)$\\ 
$\spcx	\ra \List A\; i \ra \List A\; \infty$\\
$\spc \quicksort i\; A\; \lleq l = \qsapp i\; A\; \lleq l (\nil A\; \infty)$ 
\end{bsp}

\subsection{Sized ordinal numbers}
Note that sized types are quite powerful. 
We can show the termination of ordinal addition with a decreasing size argument.
First, sized Brouwer Ordinals:
\begin{bsp}
$\data \Ord : \Set$ \\
$\spc \ozero : \Ord $\\
$\spc \olim : (\Nat \ra \Ord ) \ra \Ord $
\end{bsp}
Now we don't kneed Axiom 2 of the structual ordering to see that addition is terminating:
\begin{bsp}
$\fun \addOrd : \Ord \infty \ra \EPi{i}{\Size}{\Ord i \ra \Ord \infty }$\\
$\spc \addOrd x\; \inacc{\s i}\; (\ozero i) = \ozero i $\\
$\spc \addOrd x\; \inacc{\s i}\; (\olim f)  = \olim \infty ( \lam{y} \addOrd  x \; i \; (f \; y))  $
\end{bsp}

\section{Admissibility}
\subsection{Motivation}
The use of sizes needs to be constraint.
Consider for example the function definition

\begin{bsp}
$\fun \bad : \EPi{i}{\Size}{\Nat}$\\
$\spc \bad (\s i) = \bad i $ 
\end{bsp}
The termination checker will hapilly tell you that $\bad$ is terminating.
The issue here is that the size argument is not really bound to any sized data type.
But there are more subtile difficulties with using the size type.
The type of the function $\lop$
\begin{bsp}
$\EPi{i}{\Size}{\SNat i \ra \Maybe (\SNat (\s i)) \ra (Nat \ra \Maybe (\SNat i))} $ 
\end{bsp}
needs to be rejected by an admissibility checker.
\begin{figure}
$\data \Maybe (A : \Set ) : \Set$\\
$\spc  \nothing : \Maybe A$\\
$\spc  \just : A \ra\Maybe A$\\
$\const \Nat : \Set = \SNat \infty$\\
$\norec \shiftcase : (i : \Size) \ra\Maybe (\SNat (\s i)) \ra\Maybe (\SNat i)$\\
$\spc \shiftcase i (\nothing .(\SNat (\s i))) = \nothing (\SNat i)$\\
$\spc \shiftcase .i (\just .(\SNat (\s i)) (\zero i)) = \nothing (\SNat i)$\\
$\spc \shiftcase .i (\just .(\SNat (\s i)) (\suc i x)) = \just (\SNat i) x$\\
$\const \shift : (i : \Size) \ra(\Nat \ra\Maybe (\SNat (\s i))) \ra\Nat \ra\Maybe (\SNat i) =$\\ 
$\spcx \lam{i}{\lam{f}{\lam{n}{\shiftcase i (f (\suc \infty n))}}}$\\
$\const \inc : \Nat \ra\Maybe \Nat = \lam{n}{\just \Nat (\suc \infty n)}$\\
$\mutual$\\
$\spc \fun \lop : (i : \Size ) \ra\SNat i \ra(\Nat \ra\Maybe (\SNat i)) \ra\Bool$\\
$\spc \spc \lop .(\s i) (\zero i) f = \lopcase (\s i) (\zero i) f (f (\zero i))$\\
$\spc \spc \lop .(\s i) (\suc i n) f = \lop i n (\shift i f)$\\
$\spc \fun \lopcase : (i : \Size ) \ra\SNat i \ra(\Nat \ra\Maybe (\SNat i)) \ra\Maybe (\SNat i) \ra\Bool$\\
$\spc \spc \lopcase i       x f (\nothing .(\SNat i)) = \tt$\\
$\spc \spc \lopcase .(\s i)  x f (\just .(\SNat (\s i))  (\zero i)) = \tt$\\
$\spc \spc \lopcase .(\s i)  x f (\just .(\SNat (\s i)) (\suc i y)) = \lop i y (\shift i f) $\\
$\const diverge : Unit = \lop \infty\; (\zero \infty) \; \inc$\\
\caption{Loop example}
\label{loop}
\end{figure}

Otherwise, the non terminating term diverge can be constructed.

\subsection{Admissibility criterion}
Gimenez and Barthe deal with monotonicity criterions.
Abel and Pareto have worked on criterions based on continuity.

\newcommand{\mon}[3]{#1\vdash#2\mbox{ \textbf{mon} }#3}
\newcommand{\anti}[3]{#1\vdash#2\mbox{ \textbf{anti} }#3}
\newcommand{\indu}[3]{#1\vdash#2\mbox{ \textbf{ind} }#3}
\newcommand{\coind}[3]{#1\vdash#2\mbox{ \textbf{coind} }#3}
\newcommand{\admIndSize}[3]{#1\vdash#2\mbox{ \textbf{admIndSize} }#3}
\newcommand{\admCoSize}[3]{#1\vdash#2\mbox{ \textbf{admCoSize} }#3}
\newcommand{\admArg}[3]{#1\vdash#2\mbox{ \textbf{admArg} }#3}
\newcommand{\admIndRes}[3]{#1\vdash#2\mbox{ \textbf{admIndRes} }#3}
\newcommand{\admCoRes}[3]{#1\vdash#2\mbox{ \textbf{admCoRes} }#3}

\begin{figure}
\begin{gather*}
\nru{}
{\LeqVal{k}{\nF}{v}{\subst{(i,\s i)}{v}}}
{\mon{k}{v}{i}}
\qquad
\nru{}
{\LeqVal{k}{\nF}{\subst{(i,\s i)}{v}}{v}}
{\anti{k}{v}{i}}
\\[2ex]
\ndru{}
{\DD \mbox{ sized inductive type}}
{\EqVal{k}{N}{\wh s_i}{i}}
{\indu{k}{\DD p_1 \ldots p_n s_i v_1 \ldots v_m}{i}}
\qquad
\ndru{}
{\DD \mbox{ sized coinductive type}}
{\EqVal{k}{N}{\wh s_i}{i}}
{\coind{k}{\DD p_1 \ldots p_n s_i v_1 \ldots v_m}{i}}
\\[2ex]
\nru{}
{\anti{k}{v}{i} \; \mbox{ or } \indu{k}{v}{i}}
{\admArg{k}{v}{i}}
\\[2ex]
\nru{}
{\mon{k}{v}{i} \; \mbox{ or } \coind{k}{v}{i}}
{\admIndRes{k}{v}{i}}
\qquad
\nru{}
{\coind{k}{v}{i}}
{\admCoRes{k}{v}{i}}
\\[2ex]
\nru{}
{\admArg{k}{v_a}{i} 
\qquad
{\admIndSize{k+1}{\wh \cl{b}{\ins (x,k) \rho}}{i}}}
{\admIndSize{k}{\vpi x v_a \cl{b}{\rho}}{i}}
\qquad
\nru{}
{\admIndRes{k}{v}{i}}
{\admIndSize{k}{v}{i}}
\\[2ex]
\nru{}
{\admArg{k}{v_a}{i} 
\qquad
{\admCoSize{k+1}{\wh \cl{b}{\ins (x,k) \rho}}{i}}}
{\admCoSize{k}{\vpi x v_a \cl{b}{\rho}}{i}}
\qquad
\nru{}
{\admCoRes{k}{v}{i}}
{\admCoSize{k}{v}{i}}
\end{gather*}
\caption{Admissiblity}
\end{figure}

\begin{definition}
A Type $A$ is \emph{inductive in i} if it is of the form $ \DD \vec{p} \; i \: \vec{v} $ and $\DD$ is a sized inductive type
\end{definition}
\begin{definition}
A type $A$ is \emph{monotone in i} if $ \DLeqVal{A}{A[i \ra \s i ]}$ 
\end{definition}
\begin{definition}
A type $A$ is \emph{antitone in i} if $ \DLeqVal{A[i \ra \s i ]}{A}$ 
\end{definition}
Note that if a type is inductive in $i$, it is also monotone in $i$. 
Now we give a criterion for when a $\fun$ declaration is admissible.
\begin{definition}
A recursive function with type $ A_1 \ra \dots A_n \ra R $ is admissible, if
for every $A_j$ of the form $(i : \Size )$ , for $A_{j + 1} \ra \dots \ra R $ the following holds 
\begin{itemize}
\item
every argument $A_k$ is antitone or inductive in $i$
\item
the result $R$ is monotone in $i$  
\item
at least one argument $A_k$ is inductive in $i$
\end{itemize}
\end{definition}
For non-recursive definitions, even though they might seem innocent,
we still have a weakened admissiblity criterion, dropping the last requirement from the above definiton:
\begin{definition}
A non-recursive function with type $ A_1 \ra \dots A_n \ra R $ is admissible, if
for every $A_j$ of the form $(i : \Size )$ , for $A_{j + 1} \ra \dots \ra R $ the following holds 
\begin{itemize}
\item
every argument $A_k$ is antitone or inductive in $i$
\item
the result $R$ is monotone in $i$  
\end{itemize}
\end{definition}
We note that for the rejected example(Figure \ref{loop}) the argument \[\Maybe (\SNat (\s i)\] is not antitone in $i$, which rrenders the functions $\lop$ (and both $ \shiftcase$ and $\lopcase$) non-admissible.
\subsection{Examples}
We first give an example to show why we limit the form of what a sized type is.
Had we definied the sized natural numbers this way:
\begin{bsp}
$\data \BadNat ( A : \Set ) : \Size \ra \Set $ \\
$\spc \zero : \EPi{i}{\Size}{ \BadNat A \; i} $\\
$\spc \suc : \EPi{i}{\Size}{\BadNat i \ra \BadNat \; (\s i)} $
\end{bsp}
If the systemn accepted this as a sized type, then the following function would be seen terminating and admissible, while obviously looping on $\zero$.
\begin{bsp}
$\fun \foo : \EPi{i}{\Size}{\BadNat i \ra \Empty}$\\
$\spc \foo \inacc{(\s i)} \; (\zero (\s i) = \foo i \; (\zero i)$\\
$\spc \foo \inacc{(\s i)}\; (\suc i x) = \foo i \; x$
\end{bsp}
In our system, the $\BadNat$ type above is not a sized type, so the function $\foo$ is not admissible because $\BadNat i$ is not inductive in $i$.\\
For the same reason, the following function definition is also not admissible:
\begin{bsp}
$\fun \foo : \EPi{i}{\Size}{\SNat (\s i) \ra \Empty}$\\
$\spc \foo \inacc{(\s i)} \; (\zero (\s i) = \foo i \; (\zero i)$\\
$\spc \foo \inacc{(\s i)}\; (\suc i x) = \foo i x; l$
\end{bsp}
While $\SNat$ is a sized type, $\SNat (\s i)$ is not inductive in $i$.
\section{Subtyping for size}
It would be quite nice to have subtyping on sized data types.
As we are only interested in size arguments getting smaller, 
In one call to the function, the size might decrease by one, in another clause, by two.
It is enough for termination to decrease by one.
For inductive sized types like $\List$ we want for every size $i$
\begin{bsp}
$\List A\; i$ is a subtype of $\List A \; (\s i)$
\end{bsp}
and
\begin{bsp}
$\List A\; i$ is a subtype of $\List A \; \infty$.
\end{bsp}
because for inductive types the size is an upper bound for its height.
For coinductive sized types like $\Stream$ we want for every size $i$
\begin{bsp}
$\Stream (\s i) $ is a subtype of $\Stream i$
\end{bsp}
and
\begin{bsp}
$\Stream \infty$ is a subtype of $\Stream i$.
\end{bsp}
because for coinductive types the size is a lower bound for its definedness.
There is natural order on size expressions.
We define a substage relation on size values:
\[\SzLeq{v_1}{v_2} \subseteq Val \times Val \]
Now we the subtype relation similar to the equality relation by two simulatemous judgements:
\[\LeqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times \Val \times \Val \]
\[\FleqVal{f}{k}{v_1}{v_2} \subseteq \cF \times \cN \times\Val \times \Val \]
Of special interest are the rules:
\begin{itemize}
\item
$\leqappind$: subtyping for sized inductiv type 
\item
$\leqappco$: subtyping for sized coinductive type
\item
$\leqappd$: subtyping for other data types
\item
$\leqpi$: subtyping for function space. 
\end{itemize}
\begin{figure}
\begin{gather*}
\nru{\sleqinfty}
{}
{\SzLeq{v}{\infty}}
\qquad
\nru{\sleqgen}
{}
{\SzLeq{k}{k}}
\\[2ex]
\nru{\sleqsucci}
{\SzLeq{v_1}{v_2}}
{\SzLeq{\s v_1}{\s v_2}}
\qquad
\nru{\sleqsuccii}
{\SzLeq{v_1}{v_2}}
{\SzLeq{v_1}{\s v_2}}
\end{gather*}
\caption{Size comparison}
\end{figure}

\begin{figure}[p]
\begin{gather*}
%% Force L
\nru{\leqlf}
{\forc \; v_1 = u_1 \qquad \forc \; v_2 = \stuck 
\qquad
f \neq \rF \qquad \FleqVal{\lF}{k}{u_1}{v_2}}
{ \LeqVal{f}{k}{v_1}{v_2}}
%% Force R
\\[2ex]
\nru{\leqrf}
{\forc \; v_1 = \stuck \qquad \forc \; v_2 = u_2 
\qquad
f \neq \lF \qquad \FleqVal{\rF}{k}{v_1}{u_2}}
{ \LeqVal{f}{k}{v_1}{v_2}}
\\[2ex]
%% Force N
\nru{\leqnf}
{\FleqVal{f}{k}{v_1}{v_2}}
{ \LeqVal{f}{k}{v_1}{v_2}}
\qquad
%% Set
\nru{\leqset}
{}
{\FleqVal{f}{k}{\Set}{\Set}}
%% Size
\\[2ex]
\nru{\leqsize}
{}
{\FleqVal{f}{k}{\Size}{\Size}}
%% Infty
\qquad
\nru{\leqinfty}
{}
{\FleqVal{f}{k}{\infty}{\infty}}
%% Succ
\\[2ex]
\nru{\leqsuc}
{\LeqVal{f}{k}{v_1}{v_2}}
{\FleqVal{f}{k}{\s v_1}{\s v_2}}
\qquad
%% Gen
\nru{\leqgen}
{}
{\FleqVal{f}{k}{k'}{k'}}
\\[2ex]
%% Ind Data
\ndru{\leqappind}
{\forall i \in Pos: \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\forall j \notin Pos : \EqVal{f}{k}{p_j}{q_j} 
}
{\forall k \in \{1,..m\}:\EqVal{f}{k}{v_k}{w_k}
\qquad
\SzLeq s t }
{\FleqVal{f}{k}{\DD p_1 \ldots p_n s v_1 \ldots v_m}{\DD q_1 \ldots q_n t w_1 \ldots w_m}}
%% Co Data
\\[2ex]
\ndru{\leqappco}
{\forall i \in Pos: \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\forall j \notin Pos : \EqVal{f}{k}{p_j}{q_j}}
{\forall k \in \{1,..m\}:\EqVal{f}{k}{v_k}{w_k}
\qquad
\SzLeq t s }
{\FleqVal{f}{k}{\DD p_1 \ldots p_n s v_1 \ldots v_m}{\DD q_1 \ldots q_n s w_1 \ldots w_m}}
%% Data
\\[2ex]
\ndru{\leqappd}
{\forall i \in Pos: \LeqVal{f}{k}{p_i}{q_i} 
\qquad
\forall j \notin Pos : \EqVal{f}{k}{p_j}{q_j}}
{\forall k \in \{1,..m\}:\EqVal{f}{k}{v_k}{w_k}}
{\FleqVal{f}{k}{\DD p_1 \ldots p_n v_1 \ldots v_m}{\DD q_1 \ldots q_n w_1 \ldots w_m}}
%%App
\\[2ex]
\nru{\leqapp}
{\LeqVal{f}{k}{v_1}{v_2} \qquad
\EqVal{f}{k}{c_1}{d_1} \ldots \EqVal{f}{k}{c_n}{d_n}}
{\FleqVal{f}{k}{v_1 (c_1 \ldots c_n)}{v_2 (d_1 \ldots d_n)}}
%% Pi
\\[2ex]
\nru{\leqpi}
{\LeqVal{f}{k}{a_2}{a_1}
\qquad
\LeqVal{f}{k+1}{\wh b_1 (\ins \; \rho_1 \; (x_1,k))}{\wh b_2 (\ins \; \rho_2 \; (x_2,k))}}
{\FleqVal{f}{k}{\vpi \; x_1 \; a_1 \; \cl{b_1}{\rho_1}}{\vpi \; x_2 \; a_2 \; \cl{b_2}{\rho_2}}}
%% Lam
\\[2ex]
\nru{\leqlam}
{\LeqVal{f}{k+1}{\wh b_1 (\ins \; \rho_1 \; (x_1,k))}{\wh b_2 (\ins \; \rho_2 \; (x_2,k))}}
{\FleqVal{f}{k}{\vlam \; x_1 \; \cl{b_1}{\rho_1}}{\vlam \; x_2 \; (\cl{b_2}{\rho_2}}}
%% Def
\\[2ex]
\nru{\leqdef}
{}
{\FleqVal{f}{k}{\ff}{\ff}}
%% Con
\qquad
\nru{\leqcon}
{}
{\FleqVal{f}{k}{\cc}{\cc}}
\end{gather*}
\caption{subtype checking}
\end{figure}

\chapter{Adding coinductive types}

Coinductive types allow the introduction of (possibly) infinite objects in type theory.
The analogon to list are colists. This type includes all finite and infinite lists.
The list of all natural numbers is an example of an infinite colist.
While we can't look at all natural numbers in a finite time, we should expect to be able to
compute any finite part of a colist in finite time.
Functions that define corecursive objects are corecustive functions.
This is possible for \emph{productive} coinductive definitions.
There are syntactic criteria for checking productivity of coinductive definitons.
But in the following, we will use the size type introduced earlier to prove termination.

\begin{itemize}
\item
coinductive datatype:
\[\codata \; \DD \; \tau : t \; \vec{\gamma}\]  

\item
coinductive function:
\[\cofun \; \ff \; : \; t \; \vec{\kappa}\]
\end{itemize}

\section{Syntax}

\section{Lazy values}
Unrolling of corecursive functions needs to be restricted.
Force is used in specific places.

\section{Examples}

\subsection{Streams}
Now we introduce streams of natural numbers.
\begin{bsp}
$\codata Stream : \Set $ \\
$\spc \cons : \Nat \ra \Stream \ra \Stream $
\end{bsp}
Note that because $\Stream$ has only one constructor, there are no finite $\Stream$ objects.
A stream of zeroes can be generated by:
\begin{bsp}
$\cofun \ones: \Stream $ \\
$\spc \ones = : \cons \zero \ones$
\end{bsp}

An example of an unproductive stream is $\unp$:
\begin{bsp}
$\cofun \unp : \Stream $ \\
$\spc \unp = : \unp$
\end{bsp}
We can look at any element of $\ones$ .
But looking at a element $\unp$ is not defined. 
A syntactic criterion for productivity of coinductive definitions is the guardness condition:
Every (co)recursive call must be guarded by a constructor.
In the above example , the call to $\ones$ is guarded by $\cons$
But we want to use sized types for productivity checking.
\subsection{Sized Streams}
Let us now explain how sized types , in comnbination with the current terminatin criterion, can be used for showing productivity.
First we introduce the sized coinductive type 
\begin{bsp}
$\codata \Stream : \Size \ra \Set $ \\
$\spc \cons : \EPi{i}{\Size}{\Nat \ra \Stream i \; \ra \Stream (\s i) } $
\end{bsp}
For the productive stream $\ones$, we turn it into
\begin{bsp}
$\cofun \ones: \EPi{i}{Size}{\Stream i} $ \\
$\spc \ones (\s i) = \cons i \zero (\ones i)$\\
$\spc \const \ones \Stream \infty = \ones \infty $
\end{bsp}
The termination checker sees that the recursive call happens on a smaller size.
For the unproductive stream, we have two bad choices:
The first one
\begin{bsp}
$\cofun \unp : \EPi{i}{\Size}{\Stream i}$ \\
$\spc \unp i =  \unp i$
\end{bsp}
is type correct, but the call is not on a smaller size.
The second option is
\begin{bsp}
$\cofun \unp : \EPi{i}{\Size}{\Stream i}$ \\
$\spc \unp (\s i) = \unp i $
\end{bsp}
is accepted by the termination checker, but thankfully is not type correct.
\subsection{Fibonacci stream}

Helper functions head, tail:
\begin{bsp}
$\norec \tail : \EPi{i}{\Size}\Stream (\s i) \ra \Stream i$\\
$\spc \tail \; .i \; (\cons A \; i \; n \; ns) = ns$\\
$\norec \head : \EPi{i}{\Size}\Stream (\s i) \ra \Nat$\\
$\spc \head \; .i \; (\cons A \; i \; n \; ns) = n$
\end{bsp}
Note that these a $\norec$ functions because they are not recursive. Besides, their type would not be admissble as a $\fun$.
We can now define looking up the nth element of a Stream.
\begin{bsp}
$\fun nth : \Nat \ra \Stream \infty \ra \Nat$\\
$\nth \zero ns = \head \infty ns$\\
$\nth (\suc n) \; ns = nth n (\tail \infty ns)$\\
\end{bsp}
Then, we introduce the helper function $\zipWith$:
\begin{bsp}
$\cofun \zipWith : (\Nat \ra \Nat ) \ra \EPi{i}{\Size}{\Stream i \ra \Stream i \ra \Stream i}$ \\
$\spc \zipWith f \; (\s i) \; as bs = \cons i \; (f \; a \; b) (\zipWith f \; i \; (\tail i \; as) (\tail i \; bs)$
\end{bsp}
Finally we can define the stream of all fibonacci streams:
\begin{bsp}
$\cofun \fib : \EPi{i}{\Size}\Stream i$\\
$\spc \fib (\s \s i) = \cons (\s i) \; \zero (\cons i \; (\suc \zero)$\\
$\spcx (\zipWith \add \; i \; (\fib i) \; (\tail i (\fib (\s i)))))$
\end{bsp}
and get the fourth fibonacci number by:
\begin{bsp}
$\const \fibf : \Nat = \nth (\suc (\suc (\suc (\suc \zero )))) \; (\fib \infty)$
\end{bsp}
\subsection{Stream processors}
\subsection{Colists and conatural numbers}
\section{Admissibility}
We now have to define when a $\cofun$ declaration is admissible.
\begin{definition}
A corecursive function with type $ A_1 \ra \dots A_n \ra R $ is admissible, if
for every $A_j$ of the form $(i : \Size )$ , for $A_{j + 1} \ra \dots \ra R $ the following holds 
\begin{itemize}
\item
every argument $A_k$ is antitone or inductive in $i$
\item
the result $R$ is coinductive in $i$  
\end{itemize}
\end{definition}
It follows from the definition that one can only use on size argument, because it has to be coinductive in the result type.
\chapter{Implementation}
MiniAgda was implemented in the function language Haskell \cite{haskell}.
\section{Overview}
\begin{itemize}
\item
\texttt{Abstract.hs} : Syntax for expressions , patterns, and declarations
\item
\texttt{Values.hs} : Values and related functions: eval, whnf 
\item
\texttt{TypeChecker.hs} : TypeChecking with Admissiblity checking
\item
\texttt{Termination.hs} : structural Termination checker
\item
Main.hs : the main module
\item
\text{example} dir: example input files
\end{itemize}

\section{Usage}

\begin{itemize}
\item
lists of constructors and clauses are grouped with brackets \texttt{\{},\texttt{\}} and separated with semicolon \texttt{;}
\item
$\EPi{x}{A}{B}$ is written \texttt{(x : A) -> B }
\item
$A \ra B$ is written \texttt{A -> B}
\item
$ \lam{x}e$ is written \texttt{\\ x -> e }
\item
$ \inacc{e}$ is written \texttt {.e} 
\item
$ \infty$ is written \texttt{\#} 
\item
$\s$ is written \texttt{\$}
\end{itemize}
\texttt{const} can be replaced with {\texttt {eval const}}. Then the value will be evaluated after type checking is done.
As an example showing all syntactial features, here is the fibonacci stream example (\texttt{examples/fib.ma}) in ASCII format:
\begin{verbatim}
data Nat : Set {
  zero : Nat;
  succ : Nat -> Nat 
}

fun add : Nat -> Nat -> Nat {
  add zero = \y -> y;
  add (succ x) = \y -> succ (add x y)
}

codata Stream : Size -> Set {
  cons : (i : Size) -> Nat -> Stream i -> Stream ($ i)
}
 
norec tail : (i : Size) -> Stream ($ i) -> Stream i {
  tail .i (cons i n ns) = ns
}

norec head : (i : Size) -> Stream ($ i) -> Nat {
  head .i (cons i n ns) = n
}

cofun zipWith :  (Nat -> Nat -> Nat ) -> ( i : Size ) 
		-> Stream i -> Stream i -> Stream i {
  zipWith f ($ i) as bs = 
	cons i (f (head i as) (head i bs))  (zipWith f i (tail i as) (tail i bs)) 
}

fun nth : Nat -> Stream # -> Nat {
  nth zero ns = head # ns;
  nth (succ x) ns = nth x (tail # ns) 
}

cofun fibs : ( i : Size ) -> Stream i
{
  fibs ($ $ i) = cons ($ i) zero (cons i (succ zero)
	 	(zipWith add i (fibs i) (tail i (fibs ($ i)))))
}

const 4 : Nat = (succ (succ (succ (succ zero))))
-- fib(4) = 3 
eval const fib4 : Nat = nth 4 (fibs ) 

\end{verbatim}
Running \texttt{Main examples/fib.ma} yields the console output:
\begin{verbatim}
./Main examples/fib.ma
***** MiniAgda v1.0 *****
--- scope checking ---
--- termination checking ---
--- type checking ---
Stream is a sized type 
--- evaluating constants ---
fib4 evaluates to (succ (succ (succ zero)))

\end{verbatim}

\section{Parsing}
The alex \cite{alex} and happy \cite{happy} tools where used for generating lexer and parser.

The checkers use monad transformers (\cite{Grabmueller2006MonadTransformers}).

\section{Scope checking}
The first step after parsing is scope checking. This checks that names are used correctly:
all declared constants should have a uniquie name and variables bound by 
The use of linear patterns is also restricted at scope checking.
Thus, all used identifiers can be categorized as refering to a constructor, a variable or a definied data type or
function.
After scope checking, it is guaranteed that looking up in signature or environments is guaranteed to succeed.
\subsection{Type Checking}
Type checking was implemented as explained above.
\subsection{Termination Checking}
Termination checking was implemented as explained.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "da"
%%% End: 
